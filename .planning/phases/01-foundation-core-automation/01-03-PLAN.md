---
phase: 01-foundation-core-automation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/screenshots/dual-format.ts
  - src/screenshots/screenshot-manager.ts
  - src/screenshots/index.ts
  - src/artifacts/artifact-storage.ts
  - src/artifacts/index.ts
autonomous: true

must_haves:
  truths:
    - "Screenshots are saved in both PNG and WebP formats simultaneously"
    - "WebP files are at least 25% smaller than PNG originals"
    - "Duplicate screenshots are detected by content hash and not re-saved"
    - "Artifacts persist as JSON files on disk and can be loaded back"
    - "Artifacts include schema version for future compatibility"
  artifacts:
    - path: "src/screenshots/dual-format.ts"
      provides: "PNG to WebP conversion with Sharp"
      exports: ["convertToWebP", "captureDualFormat"]
      contains: "sharp"
    - path: "src/screenshots/screenshot-manager.ts"
      provides: "Screenshot capture coordination with deduplication"
      exports: ["ScreenshotManager"]
      contains: "sha256"
    - path: "src/artifacts/artifact-storage.ts"
      provides: "JSON file persistence for pipeline artifacts"
      exports: ["ArtifactStorage"]
      contains: "writeJson"
    - path: "src/screenshots/index.ts"
      provides: "Barrel export for screenshots module"
    - path: "src/artifacts/index.ts"
      provides: "Barrel export for artifacts module"
  key_links:
    - from: "src/screenshots/dual-format.ts"
      to: "sharp"
      via: "WebP conversion"
      pattern: "sharp.*\\.webp"
    - from: "src/screenshots/screenshot-manager.ts"
      to: "src/screenshots/dual-format.ts"
      via: "uses captureDualFormat for conversion"
      pattern: "captureDualFormat"
    - from: "src/screenshots/screenshot-manager.ts"
      to: "src/types/artifacts.ts"
      via: "returns ScreenshotRef objects"
      pattern: "ScreenshotRef"
    - from: "src/artifacts/artifact-storage.ts"
      to: "src/types/artifacts.ts"
      via: "uses ArtifactMetadata for type safety"
      pattern: "ArtifactMetadata"
---

<objective>
Implement dual-format screenshot capture (PNG for LLM analysis + WebP for display) with content-hash deduplication, and JSON-based artifact storage that persists pipeline outputs for debugging and resume capability.

Purpose: Screenshots feed into Phase 4 (AI analysis) and Phase 5 (reports). Artifact storage enables every pipeline stage to persist and resume. Both are foundational infrastructure.
Output: Screenshot manager producing dual-format images with deduplication, and artifact storage system writing versioned JSON files.
</objective>

<execution_context>
@C:\Users\Shiv_\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Shiv_\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-core-automation/01-RESEARCH.md
@src/types/artifacts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement dual-format screenshot capture with deduplication</name>
  <files>
    src/screenshots/dual-format.ts
    src/screenshots/screenshot-manager.ts
    src/screenshots/index.ts
  </files>
  <action>
    **dual-format.ts:**

    1. Import sharp (default import -- sharp uses CJS under the hood but works with ESM interop)
    2. Export `convertToWebP(pngBuffer: Buffer): Promise<Buffer>` that:
       - Uses sharp(pngBuffer).webp({ quality: 80, effort: 4, smartSubsample: true }).toBuffer()
       - Returns the WebP buffer
    3. Export `captureDualFormat(page: Page, name: string, outputDir: string): Promise<ScreenshotRef>` that:
       - Captures full-page PNG screenshot from Playwright page: `page.screenshot({ type: 'png', fullPage: true })`
       - Generates content hash: SHA-256 of PNG buffer, first 12 hex chars
       - Converts to WebP via convertToWebP()
       - Writes both files using path.join() (cross-platform):
         - `{outputDir}/{name}-{hash}.png`
         - `{outputDir}/{name}-{hash}.webp`
       - Gets dimensions via sharp(pngBuffer).metadata()
       - Calculates size reduction percentage
       - Returns ScreenshotRef object (from types)

    Import `crypto` from 'node:crypto' and `path` from 'node:path'. Use node: prefix for built-in modules.
    Use `fs-extra` for ensureDirSync and writeFile.

    **screenshot-manager.ts:**

    Create `ScreenshotManager` class:
    1. Constructor takes `outputDir: string` (defaults to '.afterburn/screenshots')
    2. Maintains a `Map<string, ScreenshotRef>` for deduplication (hash -> existing ref)
    3. `async capture(page: Page, name: string): Promise<ScreenshotRef>`:
       - Captures PNG buffer from page
       - Computes hash
       - If hash exists in dedup map, returns existing ref (skip write)
       - Otherwise calls captureDualFormat, stores in map, returns ref
    4. `getAll(): ScreenshotRef[]` -- returns all captured screenshots
    5. `getByName(name: string): ScreenshotRef | undefined` -- lookup by name

    Do NOT convert synchronously -- all Sharp operations must be async.
    Do NOT use path string concatenation -- use path.join() for Windows compatibility.
    Do NOT store screenshots in memory -- write to disk immediately, only keep refs.

    **index.ts:**

    Barrel export from dual-format.js and screenshot-manager.js.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - dual-format.ts imports sharp and exports captureDualFormat
    - screenshot-manager.ts uses content hash Map for deduplication
    - All paths use path.join() (grep for string concatenation with '/' to verify none exists)
  </verify>
  <done>
    ScreenshotManager captures dual-format screenshots (PNG + WebP) with content-hash deduplication. WebP conversion uses Sharp with quality 80 settings. All paths are cross-platform via path.join().
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement JSON artifact storage with versioning and cleanup</name>
  <files>
    src/artifacts/artifact-storage.ts
    src/artifacts/index.ts
  </files>
  <action>
    **artifact-storage.ts:**

    Create `ArtifactStorage` class (following RESEARCH.md pattern):

    1. Constructor takes `baseDir: string` (defaults to '.afterburn/artifacts')
       - Calls `fs.ensureDirSync(this.baseDir)` to create directory on init
    2. `async save<T extends ArtifactMetadata>(artifact: T): Promise<string>`:
       - Generates filename: `{artifact.stage}-{artifact.sessionId}.json`
       - Writes JSON with 2-space pretty formatting: `fs.writeJson(filepath, artifact, { spaces: 2 })`
       - Returns the filepath
    3. `async load<T extends ArtifactMetadata>(stage: string, sessionId: string): Promise<T>`:
       - Reads JSON from `{stage}-{sessionId}.json`
       - Throws descriptive error if file not found
       - Returns parsed artifact
    4. `async exists(stage: string, sessionId: string): Promise<boolean>`:
       - Returns true if artifact file exists
    5. `async list(stage?: string): Promise<string[]>`:
       - Lists all artifact files, optionally filtered by stage prefix
    6. `async cleanup(olderThanDays: number = 7): Promise<number>`:
       - Removes artifacts older than N days based on file mtime
       - Returns count of deleted files

    Import `fs` from 'fs-extra' (not native fs -- fs-extra provides writeJson, readJson, ensureDirSync).
    Use `path` from 'node:path' for all path operations.

    Do NOT store artifacts in memory -- read/write from disk each time (artifacts can be large).
    Do NOT use synchronous file operations except ensureDirSync in constructor.

    **index.ts:**

    Barrel export from artifact-storage.js.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - ArtifactStorage has save(), load(), exists(), list(), cleanup() methods
    - Uses fs-extra for JSON operations (not manual JSON.stringify + fs.writeFile)
    - All paths use path.join()
  </verify>
  <done>
    ArtifactStorage persists pipeline artifacts as versioned JSON files with save/load/list/cleanup operations. Files are human-readable (2-space indented) for debugging. Cleanup removes artifacts older than 7 days by default.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes for entire project
- src/screenshots/ contains 3 files: dual-format.ts, screenshot-manager.ts, index.ts
- src/artifacts/ contains 2 files: artifact-storage.ts, index.ts
- dual-format.ts uses sharp for WebP conversion with quality 80
- screenshot-manager.ts deduplicates by content hash
- artifact-storage.ts uses fs-extra for JSON persistence
</verification>

<success_criteria>
- Dual-format capture produces both PNG and WebP from a single Playwright screenshot
- Content-hash deduplication prevents redundant file writes
- Artifact storage saves/loads versioned JSON with proper typing
- All file paths are cross-platform (path.join, not string concat)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-automation/01-03-SUMMARY.md`
</output>
