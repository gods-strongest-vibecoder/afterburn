---
phase: 04-analysis-diagnosis
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/analysis/source-mapper.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "When user provides --source ./path, tool cross-references errors with actual source code"
    - "Tool pinpoints likely file and line number when source code is provided"
    - "Source analysis gracefully skips when tsconfig.json not found or path invalid"
    - "Source analysis has 10-second timeout to prevent hanging on large codebases"
  artifacts:
    - path: "src/analysis/source-mapper.ts"
      provides: "Source code pinpointing using ts-morph AST analysis"
      exports: ["mapErrorToSource"]
  key_links:
    - from: "src/analysis/source-mapper.ts"
      to: "ts-morph"
      via: "Project class for TypeScript AST analysis"
      pattern: "new Project"
    - from: "src/analysis/source-mapper.ts"
      to: "src/types/execution.ts"
      via: "imports StepResult for error context"
      pattern: "import.*execution"
---

<objective>
Create source code mapper that uses ts-morph to cross-reference browser errors with actual TypeScript/JavaScript source code, pinpointing likely file and line numbers.

Purpose: When vibe coders provide their source code via `--source ./path`, Afterburn can tell them exactly WHERE in their code the bug likely lives -- not just that something broke, but which file and line to look at.

Output: source-mapper.ts that accepts error messages and a source path, uses ts-morph AST analysis to find likely code locations, with graceful timeout and fallback behavior.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-analysis-diagnosis/04-RESEARCH.md

# Key source files
@src/types/execution.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install ts-morph and create source mapper</name>
  <files>package.json, src/analysis/source-mapper.ts</files>
  <action>
**Install ts-morph:**
```bash
npm install ts-morph
```

**Create src/analysis/source-mapper.ts** with:

1. `SourceLocation` interface (or import from diagnosis-schema if available, otherwise define locally):
   - `file`: string (relative file path)
   - `line`: number
   - `context`: string (first ~200 chars of the relevant code block)

2. `mapErrorToSource(errorMessage: string, sourcePath: string): Promise<SourceLocation | null>` - main export:
   - Wrap entire function in a 10-second timeout using `Promise.race` with a timer
   - Check if sourcePath exists and contains tsconfig.json
   - If no tsconfig.json, try to find .ts/.tsx/.js/.jsx files manually with `addSourceFilesAtPaths([sourcePath + '/**/*.{ts,tsx,js,jsx}'])`
   - Extract search terms from error message using `extractSearchTerms()`:
     - Look for identifiers after common patterns: "Cannot read properties of", "is not a function", "is not defined"
     - Extract text inside quotes or backticks
     - Extract camelCase or PascalCase identifiers
     - Extract function-like patterns: word followed by `(`
   - Search source files for matches:
     a. Search function declarations and arrow functions by name
     b. Search class declarations by name
     c. Search variable declarations by name
     d. Search for string literals matching error text
   - For each match, compute relevance score:
     - Exact name match: 10 points
     - Partial name match (contains): 5 points
     - String literal match: 3 points
   - Return highest-scoring match as SourceLocation with:
     - `file`: relative path from sourcePath (use path.relative)
     - `line`: getStartLineNumber()
     - `context`: first 200 chars of getText()
   - Return null if no matches found or on timeout

3. `extractSearchTerms(errorMessage: string): string[]` - helper:
   - Strip common prefixes: "Error:", "TypeError:", "ReferenceError:"
   - Extract quoted strings: text between ' or " or `
   - Extract identifiers after "Cannot read property" / "Cannot read properties of"
   - Extract identifiers before "is not a function" / "is not defined"
   - Extract URL path segments that look like route handlers
   - Filter out common words: "undefined", "null", "object", "string", "number", "the", "of", "is"
   - Return unique terms sorted by length (longer = more specific = search first)

4. `mapMultipleErrors(errors: Array<{ message: string }>, sourcePath: string): Promise<Map<string, SourceLocation>>` - batch helper:
   - Load ts-morph Project ONCE
   - Search for each error's terms against the same project
   - Return Map of error message -> SourceLocation
   - Share the 10-second timeout across all searches (not per-error)

Handle edge cases:
- sourcePath doesn't exist: return null, log warning
- tsconfig.json not found: still load .ts files manually
- ts-morph throws: catch and return null (graceful degradation)
- Timeout: return null with no error (just couldn't find it in time)

Add 1-2 line header comment explaining purpose.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no type errors. Verify ts-morph is in package.json dependencies.</verify>
  <done>Source mapper can analyze TypeScript/JavaScript source code to find likely error locations. Handles missing tsconfig.json, invalid paths, and large codebases gracefully with 10-second timeout. ts-morph installed as dependency.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. ts-morph appears in package.json dependencies
3. src/analysis/source-mapper.ts exports mapErrorToSource and mapMultipleErrors
4. Source mapper handles missing sourcePath gracefully (returns null, no crash)
5. Source mapper has 10-second timeout protection
</verification>

<success_criteria>
- ts-morph installed and compiles correctly
- Source mapper extracts search terms from error messages
- Source mapper searches TypeScript AST for matching code locations
- Returns file path and line number for best match
- Graceful degradation on all error paths (missing files, timeout, parse errors)
</success_criteria>

<output>
After completion, create `.planning/phases/04-analysis-diagnosis/04-02-SUMMARY.md`
</output>
