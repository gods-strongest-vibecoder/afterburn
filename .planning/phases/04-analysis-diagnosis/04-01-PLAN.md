---
phase: 04-analysis-diagnosis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/analysis/diagnosis-schema.ts
  - src/analysis/error-analyzer.ts
  - src/ai/gemini-client.ts
autonomous: true

must_haves:
  truths:
    - "AI analyzes browser evidence (console errors, network failures, DOM state) for each workflow error"
    - "AI infers likely root cause from evidence and provides plain English explanation"
    - "Diagnosis includes confidence level and actionable fix suggestion"
    - "Graceful degradation when GEMINI_API_KEY not set (basic pattern-matching fallback)"
  artifacts:
    - path: "src/analysis/diagnosis-schema.ts"
      provides: "Zod schemas for error diagnosis and UI audit structured output"
      exports: ["ErrorDiagnosisSchema", "UIAuditSchema", "AnalysisArtifact"]
    - path: "src/analysis/error-analyzer.ts"
      provides: "Error diagnosis using LLM analysis of browser evidence"
      exports: ["analyzeErrors"]
    - path: "src/ai/gemini-client.ts"
      provides: "Extended GeminiClient with multimodal (image) support"
      exports: ["GeminiClient"]
  key_links:
    - from: "src/analysis/error-analyzer.ts"
      to: "src/ai/gemini-client.ts"
      via: "GeminiClient.generateStructured with evidence prompt"
      pattern: "gemini\\.generateStructured"
    - from: "src/analysis/error-analyzer.ts"
      to: "src/types/execution.ts"
      via: "imports ExecutionArtifact, StepResult, ErrorEvidence"
      pattern: "import.*execution"
    - from: "src/analysis/diagnosis-schema.ts"
      to: "zod"
      via: "Zod schema definitions"
      pattern: "z\\.object"
---

<objective>
Create error diagnosis schemas and LLM-powered error analyzer that transforms raw Phase 3 execution evidence into plain English diagnoses with root cause analysis.

Purpose: This is the core AI intelligence of Afterburn -- turning raw browser evidence (console errors, network failures, screenshots) into actionable explanations that vibe coders can understand without technical expertise.

Output: diagnosis-schema.ts with Zod schemas for all Phase 4 structured output, error-analyzer.ts that processes ExecutionArtifact errors through Gemini LLM, and extended GeminiClient with multimodal image support.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-analysis-diagnosis/04-RESEARCH.md

# Key source files
@src/ai/gemini-client.ts
@src/types/execution.ts
@src/types/discovery.ts
@src/execution/workflow-executor.ts
@src/execution/evidence-capture.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Diagnosis schemas and GeminiClient multimodal extension</name>
  <files>src/analysis/diagnosis-schema.ts, src/ai/gemini-client.ts</files>
  <action>
**Create src/analysis/diagnosis-schema.ts** with all Zod schemas for Phase 4 structured output:

1. `ErrorDiagnosisSchema` - z.object with:
   - `summary`: string ("One-sentence plain English summary of what went wrong")
   - `rootCause`: string ("Plain English explanation of the root cause")
   - `errorType`: enum ['network', 'javascript', 'dom', 'form', 'navigation', 'authentication', 'unknown']
   - `confidence`: enum ['high', 'medium', 'low']
   - `suggestedFix`: string ("Actionable next step in plain English")
   - `technicalDetails`: string optional ("Technical details for developers")

2. `UIAuditSchema` - z.object with:
   - `layoutIssues`: array of { description: string, severity: enum ['high','medium','low'], location: string }
   - `contrastIssues`: array of { element: string, issue: string, suggestion: string }
   - `formattingIssues`: array of { problem: string, suggestion: string }
   - `improvements`: array of strings ("Plain English improvement suggestions")
   - `overallScore`: enum ['good', 'needs-work', 'poor']

3. `SourceLocationSchema` - z.object with:
   - `file`: string
   - `line`: number
   - `context`: string ("First ~200 chars of relevant code")

4. `DiagnosedError` type - combines ErrorDiagnosis with optional sourceLocation and screenshotRef

5. `UIAuditResult` type - UIAudit with pageUrl and screenshotRef

6. `AnalysisArtifact` interface extending ArtifactMetadata with:
   - `diagnosedErrors`: DiagnosedError[]
   - `uiAudits`: UIAuditResult[]
   - `sourceAnalysisAvailable`: boolean
   - `aiPowered`: boolean (false when GEMINI_API_KEY not set)

Export all schemas and inferred TypeScript types.

**Extend src/ai/gemini-client.ts** with a `generateStructuredWithImage` method:
- Signature: `async generateStructuredWithImage<T>(prompt: string, schema: z.ZodType<T>, imagePath: string): Promise<T>`
- Read PNG file from imagePath using `fs.readFileSync(imagePath, { encoding: 'base64' })`
- Build content with both text part and inlineData part: `{ inlineData: { mimeType: 'image/png', data: base64Data } }`
- Use same generationConfig pattern as existing `generateStructured` (responseMimeType: 'application/json', responseSchema from zodToJsonSchema)
- Validate response with schema.parse() just like existing method
- Add `import fs from 'node:fs';` at top of file

Add 1-2 line header comment to diagnosis-schema.ts.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no type errors. Check that diagnosis-schema.ts exports all schemas and types, and gemini-client.ts has the new multimodal method.</verify>
  <done>All Zod schemas defined with proper TypeScript type inference. GeminiClient extended with generateStructuredWithImage method that accepts image file path. Both files compile without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Error analyzer with LLM diagnosis and fallback</name>
  <files>src/analysis/error-analyzer.ts, src/analysis/index.ts</files>
  <action>
**Create src/analysis/error-analyzer.ts** with:

1. `analyzeErrors(artifact: ExecutionArtifact, options?: { apiKey?: string }): Promise<DiagnosedError[]>` - main export function that:
   - Collects all errors from the ExecutionArtifact: failed step results (with evidence), console errors, network failures, broken images, dead buttons, broken forms
   - If GEMINI_API_KEY available (check env or options.apiKey): use LLM diagnosis
   - If GEMINI_API_KEY NOT available: use `fallbackDiagnosis()` pattern matching

2. LLM diagnosis flow (`diagnoseWithLLM`):
   - For each failed StepResult with evidence, build a structured evidence prompt:
     ```
     Analyze this browser error and diagnose the root cause:

     Page URL: {evidence.pageUrl}
     Action attempted: {stepResult.action} on {stepResult.selector}
     Error message: {stepResult.error}

     Console Errors:
     {evidence.consoleErrors joined by newline, or "None"}

     Network Failures:
     {evidence.networkFailures mapped to "STATUS URL" joined by newline, or "None"}

     Provide a plain English diagnosis. The audience is non-technical "vibe coders" who build with AI tools.
     Focus on WHAT went wrong and HOW to fix it, not technical jargon.
     ```
   - Call `gemini.generateStructured(prompt, ErrorDiagnosisSchema)` to get structured diagnosis
   - If step has a screenshotRef with pngPath, include it for context (but error diagnosis is primarily text-based, only attach screenshot if available)
   - Also diagnose aggregate errors: console errors not tied to specific steps, network failures, broken images
   - For aggregate errors, batch them into a single prompt: "These errors were detected during testing of {url}:" followed by all evidence, ask for diagnosis of each

3. Fallback diagnosis (`fallbackDiagnosis`):
   - Pattern match on error messages to produce basic DiagnosedError without LLM:
     - Network failures (4xx/5xx): Map status codes to plain English (404 = "page not found", 500 = "server error", 403 = "permission denied")
     - Console errors containing "TypeError": "Tried to access something that doesn't exist in the code"
     - Console errors containing "ReferenceError": "Used a variable or function that wasn't defined"
     - Console errors containing "NetworkError" or "fetch": "Failed to connect to the server"
     - Dead buttons: "This button doesn't do anything when clicked"
     - Broken forms: "The form submission isn't working properly"
     - Broken images: "An image failed to load"
     - Default: "An error occurred (AI diagnosis unavailable - set GEMINI_API_KEY for detailed analysis)"
   - Set confidence to 'medium' for pattern matches, 'low' for defaults
   - Set aiPowered: false

4. Helper function `aggregateEvidencePrompt(stepResult: StepResult): string` that formats evidence into structured text for the LLM prompt.

**Create src/analysis/index.ts** barrel export:
- Export everything from diagnosis-schema.ts
- Export everything from error-analyzer.ts

Add 1-2 line header comment to error-analyzer.ts.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no type errors. Verify error-analyzer.ts imports from correct paths (../types/execution.js, ../ai/gemini-client.js, ./diagnosis-schema.js).</verify>
  <done>Error analyzer processes ExecutionArtifact into DiagnosedError array with LLM-powered root cause analysis. Fallback mode works without API key using pattern matching. All exports available from src/analysis/index.ts.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. src/analysis/diagnosis-schema.ts exports ErrorDiagnosisSchema, UIAuditSchema, SourceLocationSchema, AnalysisArtifact type
3. src/ai/gemini-client.ts has generateStructuredWithImage method accepting imagePath
4. src/analysis/error-analyzer.ts exports analyzeErrors function
5. src/analysis/index.ts barrel exports all public APIs
</verification>

<success_criteria>
- All Phase 4 Zod schemas defined and type-safe
- GeminiClient supports multimodal (text + image) structured generation
- Error analyzer transforms ExecutionArtifact errors into plain English diagnoses
- Fallback mode produces basic diagnoses without GEMINI_API_KEY
- All files compile cleanly with TypeScript
</success_criteria>

<output>
After completion, create `.planning/phases/04-analysis-diagnosis/04-01-SUMMARY.md`
</output>
