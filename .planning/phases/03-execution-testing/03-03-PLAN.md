---
phase: 03-execution-testing
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/execution/step-handlers.ts
  - src/execution/evidence-capture.ts
  - src/execution/index.ts
autonomous: true

must_haves:
  truths:
    - "Step handler fills native form fields (text, email, password, tel, select, checkbox, radio, date) using test data and skips unrecognized custom controls"
    - "Step handler clicks buttons, follows navigation, and handles redirects with 10-second timeout per step"
    - "Dead button detection compares pre/post-click state (URL, DOM, network activity) and flags buttons with no effect"
    - "Broken form detection submits a form and checks for no navigation, no network request, and no DOM change"
    - "Evidence capture takes error screenshot and collects console/network errors on step failure"
    - "Popups/modals are auto-dismissed (native dialogs via dismiss, DOM modals via close button or Escape)"
  artifacts:
    - path: "src/execution/step-handlers.ts"
      provides: "Individual step action handlers for fill, click, navigate, select, wait, expect actions with modal dismiss"
      exports: ["executeStep", "detectDeadButton", "detectBrokenForm", "fillFormFields"]
    - path: "src/execution/evidence-capture.ts"
      provides: "Error evidence collection on step failure (screenshot + context)"
      exports: ["captureErrorEvidence"]
    - path: "src/execution/index.ts"
      provides: "Updated barrel exports including step handlers and evidence capture"
  key_links:
    - from: "src/execution/step-handlers.ts"
      to: "src/execution/test-data.ts"
      via: "import getTestValueForField for form filling"
      pattern: "import.*getTestValueForField.*from.*test-data"
    - from: "src/execution/step-handlers.ts"
      to: "src/types/execution.ts"
      via: "import StepResult, DeadButtonResult, BrokenFormResult"
      pattern: "import.*StepResult.*from.*types"
    - from: "src/execution/evidence-capture.ts"
      to: "src/screenshots/index.ts"
      via: "import ScreenshotManager for error screenshots"
      pattern: "import.*ScreenshotManager.*from.*screenshots"
    - from: "src/execution/step-handlers.ts"
      to: "src/types/discovery.ts"
      via: "import WorkflowStep, FormInfo, FormField types"
      pattern: "import.*WorkflowStep.*from.*types"
---

<objective>
Create step action handlers for workflow execution: form filling, clicking, navigation, dead button detection, broken form detection, modal dismissal, and error evidence capture.

Purpose: These are the atomic action functions that the workflow executor (Plan 04) will call for each step. Each handler takes a Playwright Page and a workflow step, performs the action with a 10-second timeout, and returns a StepResult. This plan implements the core interaction logic — the intelligence of how Afterburn interacts with web pages.

Output: `src/execution/step-handlers.ts`, `src/execution/evidence-capture.ts`, updated `src/execution/index.ts`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-execution-testing/03-CONTEXT.md
@.planning/phases/03-execution-testing/03-RESEARCH.md
@src/types/artifacts.ts
@src/types/discovery.ts
@src/execution/test-data.ts (from Plan 01)
@src/execution/error-detector.ts (from Plan 01)
@src/types/execution.ts (from Plan 01)
@src/screenshots/screenshot-manager.ts
@src/browser/browser-manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Step action handlers with form filling, dead button, and broken form detection</name>
  <files>src/execution/step-handlers.ts</files>
  <action>
    Create `src/execution/step-handlers.ts`:

    Add header comment: "Workflow step action handlers: fill, click, navigate, select, wait, expect with error recovery"

    Import `Page` from `playwright`. Import `WorkflowStep`, `FormInfo`, `FormField` from `../types/discovery.js`. Import `StepResult`, `DeadButtonResult`, `BrokenFormResult` from `../types/execution.js`. Import `getTestValueForField` from `./test-data.js`.

    **Constants:**
    - `STEP_TIMEOUT = 10_000` (10 seconds per step, user requirement)
    - `NAV_TIMEOUT = 30_000` (30 seconds for navigation, pages can be slow)
    - `DEAD_BUTTON_WAIT = 1000` (1s wait after click for async changes — research used 500ms but 1s is safer)

    **`async function executeStep(page: Page, step: WorkflowStep, stepIndex: number): Promise<StepResult>`**:
    Main dispatcher. Wraps everything in try-catch. On entry, record `startTime = Date.now()`.

    Dismiss any visible modals first (call `dismissModalIfPresent(page)` — fire and forget, don't let it block).

    Switch on `step.action`:
    - `'navigate'`: `await page.goto(step.value!, { timeout: NAV_TIMEOUT, waitUntil: 'domcontentloaded' })`. Then try `await page.waitForLoadState('networkidle', { timeout: 5000 })` in a nested try-catch (SPA timeout acceptable).
    - `'click'`: `await page.locator(step.selector).click({ timeout: STEP_TIMEOUT })`.
    - `'fill'`: Call `fillField(page, step.selector, step.value ?? '', STEP_TIMEOUT)`.
    - `'select'`: `await page.locator(step.selector).selectOption(step.value!, { timeout: STEP_TIMEOUT })`.
    - `'wait'`: `await page.locator(step.selector).waitFor({ state: 'visible', timeout: STEP_TIMEOUT })`.
    - `'expect'`: `await page.locator(step.selector).waitFor({ state: 'visible', timeout: STEP_TIMEOUT })`.

    Return `StepResult` with status 'passed' and duration.

    On catch: return StepResult with status 'failed', error message, and duration. Do NOT throw — the caller (workflow executor) handles evidence capture.

    **`async function fillField(page: Page, selector: string, value: string, timeout: number): Promise<{ skipped: boolean; reason?: string }>`**:
    Private helper. Resolves the element tag and type:
    ```typescript
    const element = page.locator(selector);
    const tagName = await element.evaluate(el => el.tagName.toLowerCase(), { timeout });
    ```

    If tagName is not 'input', 'select', 'textarea', and not contenteditable: return `{ skipped: true, reason: 'custom control' }` (user requirement: skip unrecognized fields).

    For input elements, get the type: `const inputType = await element.evaluate(el => (el as HTMLInputElement).type, { timeout })`.

    Switch on inputType/tagName:
    - `'text' | 'email' | 'password' | 'tel' | 'url' | 'search' | 'number'`: `await element.fill(value, { timeout })`
    - `'textarea'`: `await element.fill(value, { timeout })`
    - `'date'`: `await element.fill(value || '2020-02-02', { timeout })`
    - `'time'`: `await element.fill(value || '13:15', { timeout })`
    - `'datetime-local'`: `await element.fill(value || '2020-02-02T13:15', { timeout })`
    - `'checkbox' | 'radio'`: `await element.setChecked(true, { timeout })`
    - `'select'` (tagName): `await element.selectOption(value, { timeout })`
    - `'file'`: return `{ skipped: true, reason: 'file upload' }` (skip file inputs)
    - default: return `{ skipped: true, reason: 'unrecognized input type: ' + inputType }`

    Return `{ skipped: false }`.

    **`async function fillFormFields(page: Page, form: FormInfo): Promise<{ filled: number; skipped: Array<{ selector: string; reason: string }> }>`**:
    Exported function for filling all fields in a form with test data.
    For each field in form.fields:
    1. Determine value: if step has a value, use it. Otherwise, call `getTestValueForField(field.name || field.label, field.type)`.
    2. If getTestValueForField returns null, skip the field and record in skipped array.
    3. Otherwise call `fillField(page, field selector within form, value, STEP_TIMEOUT)`.
    4. Track filled count and skipped array.

    The form field selector should be: within the form's selector scope. Use `page.locator(form.selector).locator(fieldSelector)` where fieldSelector is built from field attributes (name, type, label). Prefer: `[name="${field.name}"]` if field.name exists, else `input[type="${field.type}"]` as fallback. For fields with labels, try `page.locator(form.selector).getByLabel(field.label)`.

    **`async function detectDeadButton(page: Page, selector: string): Promise<DeadButtonResult>`**:
    1. Record pre-click state: `const preUrl = page.url(); const preHTML = await page.content();`
    2. Track network activity: set `networkSeen = false`, attach request listener.
    3. Click: `await page.locator(selector).click({ timeout: STEP_TIMEOUT })`.
    4. Wait for async changes: `await page.waitForTimeout(DEAD_BUTTON_WAIT)`.
    5. Record post-click state: `const postUrl = page.url(); const postHTML = await page.content();`
    6. Remove request listener.
    7. If `preUrl === postUrl && preHTML === postHTML && !networkSeen`: return `{ isDead: true, selector, reason: 'No navigation, DOM change, or network request detected after click' }`.
    8. Return `{ isDead: false, selector }`.
    Wrap in try-catch — if click itself fails, return `{ isDead: false, selector }` (can't determine, not a dead button issue).

    **`async function detectBrokenForm(page: Page, formSelector: string): Promise<BrokenFormResult>`**:
    1. Record pre-submit state: URL, page content, set networkSeen flag.
    2. Find submit button: `page.locator(formSelector).locator('button[type="submit"], input[type="submit"], button:not([type])')`.
    3. If no submit button found, try pressing Enter in the last input field.
    4. Wait 2 seconds for response.
    5. Record post-submit state.
    6. If no URL change, no DOM change, no network request: return `{ isBroken: true, formSelector, reason: 'Form submit had no effect - no navigation, network request, or DOM change', filledFields: 0, skippedFields: 0 }`.
    7. Return `{ isBroken: false, formSelector, filledFields: 0, skippedFields: 0 }`.
    Wrap in try-catch.

    **`async function dismissModalIfPresent(page: Page): Promise<void>`**:
    Private helper. Check for DOM modal:
    1. `const modal = page.getByRole('dialog');`
    2. Try `if (await modal.isVisible({ timeout: 500 }))` — short timeout, don't block.
    3. If visible, look for close button: `modal.getByRole('button', { name: /close|cancel|dismiss|x|got it|accept|ok/i })`.
    4. If found and visible, click it.
    5. If no close button, press Escape: `await page.keyboard.press('Escape')`.
    6. Catch all errors silently — modal dismissal should never crash anything.

    Also set up native dialog auto-dismiss at the start: `page.on('dialog', dialog => dialog.dismiss())`. But this should be done ONCE per page, not per step. Add a comment that the workflow executor should call this once before running steps. Do NOT register it in executeStep (would add multiple listeners).

    Export: `executeStep`, `detectDeadButton`, `detectBrokenForm`, `fillFormFields`, `dismissModalIfPresent`.
  </action>
  <verify>Run `npx tsc --noEmit` and confirm zero type errors. Verify all 5 exported functions have correct signatures.</verify>
  <done>Step handlers execute all 6 action types (navigate/click/fill/select/wait/expect) with 10s timeout. Form filling maps test data to fields and skips custom controls. Dead button detection compares pre/post-click state. Broken form detection checks submit effect. Modal dismissal handles both DOM modals and native dialogs.</done>
</task>

<task type="auto">
  <name>Task 2: Evidence capture and updated barrel exports</name>
  <files>src/execution/evidence-capture.ts, src/execution/index.ts</files>
  <action>
    Create `src/execution/evidence-capture.ts`:

    Add header comment: "Error evidence capture: screenshot + context collection on step failure"

    Import `Page` from `playwright`. Import `ErrorEvidence`, `ErrorCollector` from `../types/execution.js`. Import `ScreenshotManager` from `../screenshots/index.js`.

    **`async function captureErrorEvidence(page: Page, collector: ErrorCollector, screenshotManager: ScreenshotManager, stepIndex: number): Promise<ErrorEvidence>`**:
    1. Capture error screenshot: `const screenshotRef = await screenshotManager.capture(page, 'error-step-' + stepIndex)` (user requirement: screenshots only on errors).
    2. Collect recent console errors from collector (last 5 entries).
    3. Collect recent network failures from collector (last 5 entries).
    4. Return ErrorEvidence: `{ screenshotRef, consoleErrors: recentConsole.map(e => e.message), networkFailures: recentNetwork.map(e => ({ url: e.url, status: e.status })), pageUrl: page.url(), timestamp: new Date().toISOString() }`.

    Wrap in try-catch. On error, return minimal evidence with empty arrays and no screenshot (evidence capture should never crash workflow).

    Export `captureErrorEvidence`.

    Update `src/execution/index.ts` barrel to add:
    ```typescript
    export { executeStep, detectDeadButton, detectBrokenForm, fillFormFields, dismissModalIfPresent } from './step-handlers.js';
    export { captureErrorEvidence } from './evidence-capture.js';
    ```
    Keep existing exports from Plan 01 (TEST_DATA, getTestValueForField, setupErrorListeners).
  </action>
  <verify>Run `npx tsc --noEmit` and confirm zero type errors. Verify all exports from `src/execution/index.ts` resolve correctly.</verify>
  <done>Evidence capture collects error screenshots and context (console errors, network failures, page URL, timestamp) on step failure. Barrel exports all execution module functions.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `executeStep` handles all 6 action types: navigate, click, fill, select, wait, expect
3. `fillFormFields` uses getTestValueForField and skips unrecognized custom controls
4. `detectDeadButton` checks URL change, DOM change, and network activity
5. `detectBrokenForm` checks for form submit with no effect
6. `dismissModalIfPresent` handles DOM modals (role="dialog") and suggests native dialog handling
7. `captureErrorEvidence` captures screenshot + recent errors on failure
8. All functions wrap in try-catch and never throw to the caller
</verification>

<success_criteria>
- Step execution handles all action types with 10s timeout (30s for navigation)
- Form filling uses fixed test data, skips unrecognized fields with reason logged
- Dead button detection uses strict 3-way comparison (URL + DOM + network)
- Broken form detection catches submit-with-no-effect pattern
- Evidence capture produces screenshot + context on every failure
- All functions are resilient (try-catch, never throw)
- Modal/popup dismissal is non-blocking and handles both native dialogs and DOM modals
</success_criteria>

<output>
After completion, create `.planning/phases/03-execution-testing/03-03-SUMMARY.md`
</output>
