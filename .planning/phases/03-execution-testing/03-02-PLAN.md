---
phase: 03-execution-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/testing/accessibility-auditor.ts
  - src/testing/performance-monitor.ts
  - src/testing/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Axe-core accessibility audit runs on a Playwright page and returns WCAG 2.0/2.1 violations with impact severity"
    - "Performance monitor captures LCP and total load time from browser Performance API"
    - "@axe-core/playwright is installed as a dependency"
  artifacts:
    - path: "src/testing/accessibility-auditor.ts"
      provides: "WCAG accessibility audit via axe-core on a Playwright page"
      exports: ["auditAccessibility"]
    - path: "src/testing/performance-monitor.ts"
      provides: "LCP and load time capture via browser Performance API"
      exports: ["capturePerformanceMetrics"]
    - path: "src/testing/index.ts"
      provides: "Barrel exports for testing module"
    - path: "package.json"
      provides: "@axe-core/playwright dependency"
      contains: "@axe-core/playwright"
  key_links:
    - from: "src/testing/accessibility-auditor.ts"
      to: "@axe-core/playwright"
      via: "import AxeBuilder"
      pattern: "import.*AxeBuilder.*from.*@axe-core/playwright"
    - from: "src/testing/performance-monitor.ts"
      to: "browser Performance API"
      via: "page.evaluate with PerformanceObserver"
      pattern: "PerformanceObserver"
---

<objective>
Install @axe-core/playwright and create accessibility auditing and performance monitoring modules.

Purpose: These are standalone testing modules that run on workflow pages to capture WCAG violations and web performance metrics. They operate independently from the workflow step execution — the executor calls them on key workflow pages after steps complete. Splitting them into their own plan enables parallel development with the execution infrastructure (Plan 01).

Output: `src/testing/accessibility-auditor.ts`, `src/testing/performance-monitor.ts`, `src/testing/index.ts`, updated `package.json`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-execution-testing/03-CONTEXT.md
@.planning/phases/03-execution-testing/03-RESEARCH.md
@src/types/artifacts.ts
@src/types/discovery.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @axe-core/playwright and create accessibility auditor</name>
  <files>package.json, src/testing/accessibility-auditor.ts</files>
  <action>
    Run `npm install @axe-core/playwright` to add the dependency.

    Create `src/testing/accessibility-auditor.ts`:

    Add header comment: "WCAG accessibility audit via axe-core for Playwright pages"

    Import `AxeBuilder` from `@axe-core/playwright`. Import `Page` from `playwright`.
    Import `AccessibilityReport` and `AccessibilityViolation` from `../types/execution.js`.

    **`async function auditAccessibility(page: Page): Promise<AccessibilityReport>`**:
    1. Get current page URL: `const url = page.url();`
    2. Run axe-core analysis:
       ```
       const results = await new AxeBuilder({ page })
         .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])
         .analyze();
       ```
       The `.withTags()` targets WCAG 2.0 and 2.1 Level A and AA standards (industry baseline).
    3. Map violations to AccessibilityViolation type:
       ```
       const violations: AccessibilityViolation[] = results.violations.map(v => ({
         id: v.id,
         impact: v.impact as 'critical' | 'serious' | 'moderate' | 'minor',
         description: v.description,
         nodes: v.nodes.length,
         helpUrl: v.helpUrl,
       }));
       ```
    4. Return AccessibilityReport: `{ url, violationCount: violations.length, violations, passes: results.passes.length, incomplete: results.incomplete.length }`

    Wrap the entire function body in try-catch. On error, return a report with zero violations and a single violation entry with id "axe-error", impact "minor", description containing the error message, nodes 0, helpUrl "". This prevents axe-core failures from crashing the workflow.

    Export `auditAccessibility`.
  </action>
  <verify>Run `npx tsc --noEmit` and confirm zero type errors. Verify `@axe-core/playwright` appears in package.json dependencies.</verify>
  <done>Accessibility auditor runs WCAG 2.0/2.1 A/AA audit, returns violations with impact severity, and gracefully handles axe-core failures.</done>
</task>

<task type="auto">
  <name>Task 2: Performance monitor and testing barrel exports</name>
  <files>src/testing/performance-monitor.ts, src/testing/index.ts</files>
  <action>
    Create `src/testing/performance-monitor.ts`:

    Add header comment: "Browser performance metrics capture via Performance API"

    Import `Page` from `playwright`. Import `PerformanceMetrics` from `../types/execution.js`.

    **`async function capturePerformanceMetrics(page: Page): Promise<PerformanceMetrics>`**:
    1. Wait for load state: `await page.waitForLoadState('load');`
       Wrap in try-catch with 10s timeout — some pages never fully load.
    2. Capture LCP via page.evaluate:
       ```typescript
       const lcp = await page.evaluate(() => {
         return new Promise<number>((resolve) => {
           // Check buffered entries first
           const entries = performance.getEntriesByType('largest-contentful-paint');
           if (entries.length > 0) {
             resolve((entries[entries.length - 1] as any).startTime);
             return;
           }
           // Fall back to observer with timeout
           const timeout = setTimeout(() => resolve(0), 3000);
           new PerformanceObserver((list) => {
             clearTimeout(timeout);
             const lcpEntries = list.getEntries();
             resolve(lcpEntries.length > 0 ? (lcpEntries[lcpEntries.length - 1] as any).startTime : 0);
           }).observe({ type: 'largest-contentful-paint', buffered: true });
         });
       });
       ```
       Use `buffered: true` to catch past entries (pitfall 7 from research). Also try `performance.getEntriesByType('largest-contentful-paint')` first as a fast path for already-buffered data.
    3. Capture navigation timing:
       ```typescript
       const navTiming = await page.evaluate(() => {
         const entries = performance.getEntriesByType('navigation');
         if (entries.length === 0) return { domContentLoaded: 0, totalLoadTime: 0 };
         const perf = entries[0] as PerformanceNavigationTiming;
         return {
           domContentLoaded: Math.round(perf.domContentLoadedEventEnd - perf.startTime),
           totalLoadTime: Math.round(perf.loadEventEnd - perf.startTime),
         };
       });
       ```
    4. Return PerformanceMetrics: `{ lcp: Math.round(lcp), domContentLoaded: navTiming.domContentLoaded, totalLoadTime: navTiming.totalLoadTime, url: page.url() }`

    Wrap the entire function body in try-catch. On error, return `{ lcp: 0, domContentLoaded: 0, totalLoadTime: 0, url: page.url() }`. Performance capture should never crash the workflow.

    Export `capturePerformanceMetrics`.

    Create `src/testing/index.ts` barrel:
    ```typescript
    export { auditAccessibility } from './accessibility-auditor.js';
    export { capturePerformanceMetrics } from './performance-monitor.js';
    ```
  </action>
  <verify>Run `npx tsc --noEmit` and confirm zero type errors. Verify both functions are exported from the barrel.</verify>
  <done>Performance monitor captures LCP and total load time via browser Performance API with buffered entry support. Both testing modules export cleanly from barrel.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `@axe-core/playwright` listed in package.json dependencies
3. `src/testing/accessibility-auditor.ts` exports `auditAccessibility` that returns `AccessibilityReport`
4. `src/testing/performance-monitor.ts` exports `capturePerformanceMetrics` that returns `PerformanceMetrics`
5. Both modules handle errors gracefully (return default values, never throw)
</verification>

<success_criteria>
- @axe-core/playwright installed and importable
- Accessibility auditor targets WCAG 2.0/2.1 A/AA standards
- Performance monitor captures LCP with buffered entry support and 3s timeout fallback
- Both modules return safe defaults on error (never crash the workflow)
- Barrel exports both functions from src/testing/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/03-execution-testing/03-02-SUMMARY.md`
</output>
