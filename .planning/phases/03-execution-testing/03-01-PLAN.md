---
phase: 03-execution-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/execution.ts
  - src/types/index.ts
  - src/execution/test-data.ts
  - src/execution/error-detector.ts
  - src/execution/index.ts
autonomous: true

must_haves:
  truths:
    - "Execution result types exist for step results, error evidence, and workflow execution output"
    - "Fixed test data constants provide realistic values for every common form field type"
    - "Error detector captures console.error(), 4xx/5xx network responses, and broken images via page event listeners"
  artifacts:
    - path: "src/types/execution.ts"
      provides: "StepResult, ErrorEvidence, WorkflowExecutionResult, ErrorCollector, PerformanceMetrics, AccessibilityReport types"
      min_lines: 60
    - path: "src/execution/test-data.ts"
      provides: "TEST_DATA constant with personal, address, account, payment, and date field values"
      exports: ["TEST_DATA", "getTestValueForField"]
    - path: "src/execution/error-detector.ts"
      provides: "Page event listener setup for console errors, network failures, and broken images"
      exports: ["setupErrorListeners", "ErrorCollector"]
    - path: "src/execution/index.ts"
      provides: "Barrel exports for execution module"
  key_links:
    - from: "src/types/execution.ts"
      to: "src/types/artifacts.ts"
      via: "import ScreenshotRef"
      pattern: "import.*ScreenshotRef.*from.*artifacts"
    - from: "src/execution/error-detector.ts"
      to: "src/types/execution.ts"
      via: "import ErrorCollector type"
      pattern: "import.*ErrorCollector.*from.*types"
    - from: "src/types/index.ts"
      to: "src/types/execution.ts"
      via: "barrel re-export"
      pattern: "export.*from.*execution"
---

<objective>
Create the execution type definitions, fixed test data constants, and error detection infrastructure for Phase 3 workflow execution.

Purpose: Establishes the data contracts and passive error collection that all other execution modules depend on. Types define what step results, error evidence, and workflow execution outputs look like. Test data provides deterministic form values. Error detector sets up page-level event listeners that capture console errors, HTTP failures, and broken images without blocking workflow execution.

Output: `src/types/execution.ts`, `src/execution/test-data.ts`, `src/execution/error-detector.ts`, `src/execution/index.ts`, updated `src/types/index.ts`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-execution-testing/03-CONTEXT.md
@.planning/phases/03-execution-testing/03-RESEARCH.md
@src/types/artifacts.ts
@src/types/discovery.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Execution type definitions and test data constants</name>
  <files>src/types/execution.ts, src/types/index.ts, src/execution/test-data.ts</files>
  <action>
    Create `src/types/execution.ts` with these types:

    1. **ErrorCollector** interface:
       - `consoleErrors: Array<{ message: string; url: string; timestamp: string }>`
       - `networkFailures: Array<{ url: string; status: number; method: string; resourceType: string }>`
       - `brokenImages: Array<{ url: string; selector: string; status: number }>`

    2. **StepResult** interface:
       - `stepIndex: number`
       - `action: string` (the workflow step action)
       - `selector: string`
       - `status: 'passed' | 'failed' | 'skipped'`
       - `duration: number` (milliseconds)
       - `error?: string` (error message if failed)
       - `evidence?: ErrorEvidence` (captured on failure)
       - `skippedFields?: Array<{ selector: string; reason: string }>` (custom controls that were skipped)

    3. **ErrorEvidence** interface:
       - `screenshotRef?: ScreenshotRef` (from artifacts.ts)
       - `consoleErrors: string[]` (errors captured during this step)
       - `networkFailures: Array<{ url: string; status: number }>`
       - `pageUrl: string`
       - `timestamp: string`

    4. **DeadButtonResult** interface:
       - `isDead: boolean`
       - `selector: string`
       - `reason?: string`

    5. **BrokenFormResult** interface:
       - `isBroken: boolean`
       - `formSelector: string`
       - `reason?: string`
       - `filledFields: number`
       - `skippedFields: number`

    6. **PerformanceMetrics** interface:
       - `lcp: number` (Largest Contentful Paint in ms)
       - `domContentLoaded: number` (ms)
       - `totalLoadTime: number` (ms)
       - `url: string`

    7. **AccessibilityViolation** interface:
       - `id: string`
       - `impact: 'critical' | 'serious' | 'moderate' | 'minor'`
       - `description: string`
       - `nodes: number` (affected element count)
       - `helpUrl: string`

    8. **AccessibilityReport** interface:
       - `url: string`
       - `violationCount: number`
       - `violations: AccessibilityViolation[]`
       - `passes: number`
       - `incomplete: number`

    9. **WorkflowExecutionResult** interface:
       - `workflowName: string`
       - `description: string`
       - `totalSteps: number`
       - `passedSteps: number`
       - `failedSteps: number`
       - `skippedSteps: number`
       - `stepResults: StepResult[]`
       - `errors: ErrorCollector`
       - `overallStatus: 'passed' | 'failed'`
       - `duration: number` (total ms)

    10. **ExecutionArtifact** interface (extends ArtifactMetadata from artifacts.ts):
        - `targetUrl: string`
        - `workflowResults: WorkflowExecutionResult[]`
        - `pageAudits: Array<{ url: string; accessibility?: AccessibilityReport; performance?: PerformanceMetrics }>`
        - `deadButtons: DeadButtonResult[]`
        - `brokenForms: BrokenFormResult[]`
        - `totalIssues: number`
        - `exitCode: number`

    Update `src/types/index.ts` to add: `export * from './execution.js';`

    Create `src/execution/test-data.ts` with:
    - Fixed `TEST_DATA` constant matching the research spec: personal (John Doe, test@example.com, 555-0100), address (123 Test Street, Testville, CA, 90210), account (testuser, Test1234!), payment (4242424242424242, 12/34, 123), dates (2020-02-02, 13:15)
    - `getTestValueForField(fieldName: string, fieldType: string): string | null` function that maps field names/types to test data values. Match by: field name contains "email" -> TEST_DATA.personal.email, "password" -> TEST_DATA.account.password, "phone"/"tel" -> TEST_DATA.personal.phone, "name" -> TEST_DATA.personal.fullName, "first" -> firstName, "last" -> lastName, "street"/"address" -> street, "city" -> city, "state" -> state, "zip"/"postal" -> zip, "country" -> country, "card"/"credit" -> cardNumber, "cvv"/"cvc" -> cardCVV, "expir" -> cardExpiry. For fieldType: "email" -> email, "password" -> password, "tel" -> phone, "date" -> 2020-02-02, "time" -> 13:15, "datetime-local" -> 2020-02-02T13:15, "url" -> https://example.com. Return null for unrecognized fields (caller decides what to do).
    - Add 1-2 line header comment explaining purpose.
  </action>
  <verify>Run `npx tsc --noEmit` and confirm zero type errors. Check that `src/types/execution.ts` exports all listed types and `src/execution/test-data.ts` exports TEST_DATA and getTestValueForField.</verify>
  <done>All execution types defined, test data constants provide values for 15+ field types, getTestValueForField maps field names to values with null fallback for unrecognized fields.</done>
</task>

<task type="auto">
  <name>Task 2: Error detection event listeners and barrel exports</name>
  <files>src/execution/error-detector.ts, src/execution/index.ts</files>
  <action>
    Create `src/execution/error-detector.ts`:

    Import Page type from 'playwright' and ErrorCollector from types.

    1. **`setupErrorListeners(page: Page): ErrorCollector`** function:
       - Create ErrorCollector object with empty arrays for consoleErrors, networkFailures, brokenImages
       - Register `page.on('console', ...)` listener: only capture messages where `msg.type() === 'error'` (user requirement: ignore warnings/logs). Push `{ message: msg.text(), url: page.url(), timestamp: new Date().toISOString() }`.
       - Register `page.on('response', ...)` listener for network failures: if `response.status() >= 400`, push `{ url: response.url(), status: response.status(), method: response.request().method(), resourceType: response.request().resourceType() }`. Also check if URL matches image extensions (`/\.(jpg|jpeg|png|gif|svg|webp|avif|ico)(\?.*)?$/i`) OR resourceType is 'image' â€” if so AND status >= 400, push to brokenImages array as `{ url: response.url(), selector: 'img[src*="' + new URL(response.url()).pathname + '"]', status: response.status() }`.
       - Return the ErrorCollector object (it accumulates errors as events fire during execution).

    2. **`teardownErrorListeners(page: Page): void`** function:
       - Remove all listeners added by setupErrorListeners. Use `page.removeAllListeners('console')` and be careful NOT to remove other listeners. Better approach: have setupErrorListeners return a cleanup function alongside the collector. Refactor to: `setupErrorListeners(page: Page): { collector: ErrorCollector; cleanup: () => void }`. The cleanup function calls `page.off('console', consoleHandler)` and `page.off('response', responseHandler)` using the specific handler references.

    Add header comment explaining this module sets up passive error collection via page event listeners.

    Create `src/execution/index.ts` barrel:
    ```typescript
    export { TEST_DATA, getTestValueForField } from './test-data.js';
    export { setupErrorListeners } from './error-detector.js';
    ```

    Do NOT export types from the barrel (types come from `src/types/index.ts`).
  </action>
  <verify>Run `npx tsc --noEmit` and confirm zero type errors. Verify that importing `{ setupErrorListeners }` from `'./execution/index.js'` compiles.</verify>
  <done>Error detector sets up console.error listener (ignoring warnings/logs), 4xx/5xx network failure listener, and broken image detection listener. Returns collector object and cleanup function. Barrel exports work.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `src/types/execution.ts` contains all 10 type/interface definitions
3. `src/execution/test-data.ts` exports TEST_DATA with personal/address/account/payment sections
4. `src/execution/error-detector.ts` exports setupErrorListeners returning collector + cleanup
5. `src/types/index.ts` re-exports execution types
</verification>

<success_criteria>
- All execution types compile and are importable from `src/types/index.ts`
- TEST_DATA provides values for email, password, phone, name, address, card fields
- getTestValueForField returns correct values for 15+ field name/type combinations and null for unrecognized
- Error detector listens for console.error only (not warnings), 4xx/5xx responses, and image load failures
- No circular dependencies between types and execution modules
</success_criteria>

<output>
After completion, create `.planning/phases/03-execution-testing/03-01-SUMMARY.md`
</output>
