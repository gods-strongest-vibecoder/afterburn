---
phase: 03-execution-testing
plan: 04
type: execute
wave: 3
depends_on: ["03-01", "03-02", "03-03"]
files_modified:
  - src/execution/workflow-executor.ts
  - src/execution/index.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Workflow executor runs all steps in a workflow plan sequentially, continuing on step failure"
    - "Error listeners are active during execution, capturing console errors, HTTP failures, and broken images"
    - "Evidence (screenshot + context) is captured on every step failure"
    - "Accessibility audit and performance metrics run on key workflow pages (first and last page of each workflow)"
    - "Dead button detection runs on click steps and broken form detection runs after form fill+submit sequences"
    - "Main pipeline loads discovery artifact, executes all workflow plans, saves execution artifact, and exits with code 0 (pass) or 1 (fail)"
    - "User can provide --email and --password flags for authenticated flow testing"
    - "Execution results are saved as a JSON artifact for Phase 4 analysis"
  artifacts:
    - path: "src/execution/workflow-executor.ts"
      provides: "Workflow execution orchestrator that runs all workflow steps with error capture"
      exports: ["WorkflowExecutor"]
    - path: "src/index.ts"
      provides: "Updated main entry point with Phase 3 execution pipeline, --email/--password flags, and exit codes"
      contains: "runExecution"
  key_links:
    - from: "src/execution/workflow-executor.ts"
      to: "src/execution/step-handlers.ts"
      via: "import executeStep for running each workflow step"
      pattern: "import.*executeStep.*from.*step-handlers"
    - from: "src/execution/workflow-executor.ts"
      to: "src/execution/error-detector.ts"
      via: "import setupErrorListeners for passive error collection"
      pattern: "import.*setupErrorListeners.*from.*error-detector"
    - from: "src/execution/workflow-executor.ts"
      to: "src/execution/evidence-capture.ts"
      via: "import captureErrorEvidence for failure screenshots"
      pattern: "import.*captureErrorEvidence.*from.*evidence-capture"
    - from: "src/execution/workflow-executor.ts"
      to: "src/testing/index.ts"
      via: "import auditAccessibility and capturePerformanceMetrics"
      pattern: "import.*(auditAccessibility|capturePerformanceMetrics).*from.*testing"
    - from: "src/index.ts"
      to: "src/execution/workflow-executor.ts"
      via: "import WorkflowExecutor to run execution phase"
      pattern: "import.*WorkflowExecutor.*from.*execution"
    - from: "src/index.ts"
      to: "process.exit"
      via: "exit code based on execution results"
      pattern: "process\\.exit"
---

<objective>
Create the workflow executor that orchestrates step execution, error collection, evidence capture, and page auditing. Then integrate it into the main pipeline with CLI flags and exit codes.

Purpose: This is the central orchestrator of Phase 3. It takes workflow plans from Phase 2's discovery artifact, executes each one against the live site, captures all errors and evidence, runs accessibility and performance audits, and produces a comprehensive execution artifact for Phase 4 analysis. The main entry point is updated to run execution after discovery, accept --email/--password flags, and exit with appropriate codes.

Output: `src/execution/workflow-executor.ts`, updated `src/execution/index.ts`, updated `src/index.ts`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-execution-testing/03-CONTEXT.md
@.planning/phases/03-execution-testing/03-RESEARCH.md
@src/index.ts
@src/types/execution.ts (from Plan 01)
@src/types/discovery.ts
@src/types/artifacts.ts
@src/execution/step-handlers.ts (from Plan 03)
@src/execution/error-detector.ts (from Plan 01)
@src/execution/evidence-capture.ts (from Plan 03)
@src/execution/test-data.ts (from Plan 01)
@src/testing/accessibility-auditor.ts (from Plan 02)
@src/testing/performance-monitor.ts (from Plan 02)
@src/browser/browser-manager.ts
@src/screenshots/screenshot-manager.ts
@src/artifacts/artifact-storage.ts
@src/discovery/discovery-pipeline.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Workflow executor class</name>
  <files>src/execution/workflow-executor.ts, src/execution/index.ts</files>
  <action>
    Create `src/execution/workflow-executor.ts`:

    Add header comment: "Workflow execution orchestrator: runs workflow plans with error capture, evidence collection, and page auditing"

    Import from local modules:
    - `Page` from `playwright`
    - `BrowserManager` from `../browser/index.js`
    - `ScreenshotManager` from `../screenshots/index.js`
    - `ArtifactStorage` from `../artifacts/index.js`
    - Types: `WorkflowPlan`, `WorkflowStep` from `../types/discovery.js`
    - Types: `WorkflowExecutionResult`, `StepResult`, `ExecutionArtifact`, `ErrorCollector`, `DeadButtonResult`, `BrokenFormResult`, `AccessibilityReport`, `PerformanceMetrics` from `../types/execution.js`
    - `setupErrorListeners` from `./error-detector.js`
    - `executeStep`, `detectDeadButton`, `detectBrokenForm`, `fillFormFields`, `dismissModalIfPresent` from `./step-handlers.js`
    - `captureErrorEvidence` from `./evidence-capture.js`
    - `getTestValueForField` from `./test-data.js`
    - `auditAccessibility` from `../testing/index.js`
    - `capturePerformanceMetrics` from `../testing/index.js`

    **ExecutionOptions interface (exported):**
    - `targetUrl: string`
    - `sessionId: string`
    - `workflowPlans: WorkflowPlan[]`
    - `credentials?: { email: string; password: string }` (from --email/--password flags)
    - `onProgress?: (message: string) => void`

    **`export class WorkflowExecutor`**:

    Private fields: `browserManager`, `screenshotManager`, `artifactStorage`.

    Constructor: accepts no arguments. Creates `BrowserManager()`, `ScreenshotManager()`, `ArtifactStorage()` internally.

    **`async execute(options: ExecutionOptions): Promise<ExecutionArtifact>`**:

    Main method. Steps:

    1. Launch browser: `await this.browserManager.launch()`.
    2. Initialize tracking arrays: `workflowResults: WorkflowExecutionResult[]`, `allDeadButtons: DeadButtonResult[]`, `allBrokenForms: BrokenFormResult[]`, `pageAudits: Array<{ url: string; accessibility?: AccessibilityReport; performance?: PerformanceMetrics }>`.
    3. Track audited URLs in a Set to avoid duplicate audits.
    4. For each workflow plan in `options.workflowPlans`:
       a. Log progress: `options.onProgress?.('Executing workflow: ' + plan.workflowName)`
       b. Call `this.executeWorkflow(page, plan, options)` — returns WorkflowExecutionResult.
       c. Push result to workflowResults.
    5. Calculate total issues: sum of all failed steps across all workflows + dead buttons + broken forms + accessibility violations.
    6. Determine exit code: 0 if totalIssues === 0, 1 otherwise. (Claude's discretion per CONTEXT.md: binary pass/fail, any issue = failure for CI/CD safety.)
    7. Build ExecutionArtifact:
       ```
       {
         version: '1.0',
         stage: 'execution',
         timestamp: new Date().toISOString(),
         sessionId: options.sessionId,
         targetUrl: options.targetUrl,
         workflowResults,
         pageAudits,
         deadButtons: allDeadButtons,
         brokenForms: allBrokenForms,
         totalIssues,
         exitCode,
       }
       ```
    8. Save artifact via `this.artifactStorage.save(artifact)`.
    9. Close browser in finally block.
    10. Return artifact.

    **`private async executeWorkflow(page: Page | null, plan: WorkflowPlan, options: ExecutionOptions): Promise<WorkflowExecutionResult>`**:

    For each workflow, create a NEW page (fresh state per workflow):
    1. `const page = await this.browserManager.newPage()` (no URL — first step should navigate).
    2. Set up error listeners: `const { collector, cleanup } = setupErrorListeners(page)`.
    3. Set up native dialog auto-dismiss: `page.on('dialog', dialog => dialog.dismiss())`.
    4. If credentials provided AND workflow name suggests auth (contains 'login', 'auth', 'signin', 'sign in'): inject credentials. When a fill step targets an email/password field, override the step value with credentials.email or credentials.password.
    5. Track step results, start time.
    6. For each step in plan.steps:
       a. If step has a fill action and no value, auto-populate value from `getTestValueForField` based on selector hints (look for "email", "password", "name" in selector).
       b. If credentials provided and selector contains "email"/"username"/"user", override value with credentials.email. If selector contains "password", override with credentials.password.
       c. Call `executeStep(page, step, stepIndex)`.
       d. If step failed, call `captureErrorEvidence(page, collector, this.screenshotManager, stepIndex)` and attach to step result.
       e. If step was a click action, check for dead button: `detectDeadButton(page, step.selector)`. If dead, add to allDeadButtons.
       f. Log progress for each step.
    7. After all steps, run page audit on the FINAL page URL (key workflow page):
       - If this URL hasn't been audited yet, run `auditAccessibility(page)` and `capturePerformanceMetrics(page)`. Add to pageAudits. Add URL to audited set.
    8. Also audit the FIRST navigation URL in the workflow (if different from final). This captures the "before" state.
    9. Cleanup error listeners.
    10. Close the page.
    11. Build and return WorkflowExecutionResult:
        ```
        {
          workflowName: plan.workflowName,
          description: plan.description,
          totalSteps: plan.steps.length,
          passedSteps: stepResults.filter(r => r.status === 'passed').length,
          failedSteps: stepResults.filter(r => r.status === 'failed').length,
          skippedSteps: stepResults.filter(r => r.status === 'skipped').length,
          stepResults,
          errors: collector,
          overallStatus: stepResults.some(r => r.status === 'failed') ? 'failed' : 'passed',
          duration: Date.now() - startTime,
        }
        ```

    Wrap the entire workflow in try-catch. On error, return a failed result with error message. Continue to next workflow (user requirement: maximize coverage).

    **`async cleanup(): Promise<void>`**: Close browser safely.

    Update `src/execution/index.ts` to add:
    ```typescript
    export { WorkflowExecutor } from './workflow-executor.js';
    export type { ExecutionOptions } from './workflow-executor.js';
    ```
  </action>
  <verify>Run `npx tsc --noEmit` and confirm zero type errors. Verify WorkflowExecutor exports correctly from barrel.</verify>
  <done>WorkflowExecutor orchestrates complete workflow execution: error listener setup, step-by-step execution with continue-on-failure, evidence capture on failures, dead button detection on clicks, accessibility audit and performance metrics on key pages, credential injection for auth flows.</done>
</task>

<task type="auto">
  <name>Task 2: Pipeline integration with CLI flags and exit codes</name>
  <files>src/index.ts</files>
  <action>
    Update `src/index.ts` to add Phase 3 execution after Phase 2 discovery:

    Add imports at top:
    - `import { WorkflowExecutor } from './execution/index.js';`
    - `import type { ExecutionOptions } from './execution/index.js';`

    Add CLI flag parsing for `--email` and `--password` (same pattern as existing `--flows` parsing):
    ```typescript
    // Parse --email flag
    let email: string | undefined;
    const emailIndex = process.argv.indexOf('--email');
    if (emailIndex !== -1 && process.argv[emailIndex + 1]) {
      email = process.argv[emailIndex + 1];
    }

    // Parse --password flag
    let password: string | undefined;
    const passwordIndex = process.argv.indexOf('--password');
    if (passwordIndex !== -1 && process.argv[passwordIndex + 1]) {
      password = process.argv[passwordIndex + 1];
    }
    ```

    After the existing discovery pipeline section (after `const result = await runDiscovery(discoveryOptions);` and the discovery summary printing), add Phase 3 execution:

    ```typescript
    // Phase 3: Execute workflow plans
    if (result.workflowPlans.length > 0) {
      console.log('\n--- Phase 3: Execution & Testing ---\n');

      const executor = new WorkflowExecutor();
      const executionOptions: ExecutionOptions = {
        targetUrl,
        sessionId,
        workflowPlans: result.workflowPlans,
        credentials: email && password ? { email, password } : undefined,
        onProgress: (msg: string) => console.log(`  ${msg}`),
      };

      const executionResult = await executor.execute(executionOptions);

      // Print execution summary
      console.log('\n--- Execution Summary ---');
      console.log(`  Workflows executed: ${executionResult.workflowResults.length}`);

      for (const wr of executionResult.workflowResults) {
        const statusIcon = wr.overallStatus === 'passed' ? 'PASS' : 'FAIL';
        console.log(`  [${statusIcon}] ${wr.workflowName}: ${wr.passedSteps}/${wr.totalSteps} steps passed (${wr.duration}ms)`);

        // Show failed steps
        for (const step of wr.stepResults.filter(s => s.status === 'failed')) {
          console.log(`    Step ${step.stepIndex}: ${step.action} ${step.selector} - ${step.error}`);
        }
      }

      // Print dead buttons
      const deadButtons = executionResult.deadButtons.filter(b => b.isDead);
      if (deadButtons.length > 0) {
        console.log(`\n  Dead buttons found: ${deadButtons.length}`);
        deadButtons.forEach(b => console.log(`    - ${b.selector}: ${b.reason}`));
      }

      // Print broken forms
      const brokenForms = executionResult.brokenForms.filter(f => f.isBroken);
      if (brokenForms.length > 0) {
        console.log(`\n  Broken forms found: ${brokenForms.length}`);
        brokenForms.forEach(f => console.log(`    - ${f.formSelector}: ${f.reason}`));
      }

      // Print accessibility summary
      const totalViolations = executionResult.pageAudits.reduce(
        (sum, a) => sum + (a.accessibility?.violationCount ?? 0), 0
      );
      if (totalViolations > 0) {
        console.log(`\n  Accessibility violations: ${totalViolations}`);
        for (const audit of executionResult.pageAudits) {
          if (audit.accessibility && audit.accessibility.violationCount > 0) {
            console.log(`    ${audit.url}: ${audit.accessibility.violationCount} violations`);
            audit.accessibility.violations.slice(0, 3).forEach(v =>
              console.log(`      [${v.impact}] ${v.description} (${v.nodes} elements)`)
            );
          }
        }
      }

      // Print performance summary
      for (const audit of executionResult.pageAudits) {
        if (audit.performance && audit.performance.totalLoadTime > 0) {
          console.log(`\n  Performance: ${audit.url}`);
          console.log(`    LCP: ${audit.performance.lcp}ms, Load: ${audit.performance.totalLoadTime}ms`);
        }
      }

      console.log(`\n  Total issues: ${executionResult.totalIssues}`);
      console.log(`  Exit code: ${executionResult.exitCode}`);
      console.log(`\n  Artifact saved: .afterburn/artifacts/execution-${sessionId}.json`);

      // Exit with appropriate code (CLI-04 requirement)
      if (executionResult.exitCode !== 0) {
        process.exit(executionResult.exitCode);
      }

    } else {
      console.log('\nNo workflow plans to execute. Run with GEMINI_API_KEY set to enable AI workflow generation.');
    }
    ```

    Update the usage line at the top to include --email and --password:
    ```typescript
    console.error('Usage: afterburn <url> [--flows "flow1, flow2"] [--email user@example.com --password secret]');
    ```

    IMPORTANT: Keep all existing discovery code intact. The execution section is ADDED after discovery, not replacing it.
  </action>
  <verify>Run `npx tsc --noEmit` and confirm zero type errors. Run `npm run build` to verify the full project compiles. Check that `src/index.ts` imports WorkflowExecutor and parses --email/--password flags.</verify>
  <done>Main pipeline runs discovery then execution. Prints workflow results, dead buttons, broken forms, accessibility violations, and performance metrics. Exits with code 0 (all pass) or 1 (issues found). Supports --email/--password for authenticated flows. Execution artifact saved for Phase 4.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` compiles successfully
3. WorkflowExecutor.execute() returns ExecutionArtifact with all fields populated
4. Each workflow creates a new page with fresh error listeners
5. Failed steps get evidence captured (screenshot + context)
6. Click steps trigger dead button detection
7. Accessibility audit runs on key workflow pages (not every page)
8. Performance metrics captured on key workflow pages
9. --email/--password flags parsed and injected into auth workflows
10. Exit code 0 when no issues, 1 when any issues found
11. Execution artifact saved as `execution-{sessionId}.json`
</verification>

<success_criteria>
- Complete pipeline: discovery -> execution -> results with exit code
- Workflow execution continues on step failure (skip and log)
- Evidence captured on every failure (screenshot + console + network)
- Dead buttons detected on click steps
- Accessibility and performance audits on workflow pages
- --email/--password credentials injected into login/auth workflows
- Exit code 0 = clean, 1 = issues found (CLI-04)
- JSON artifact saved for Phase 4 consumption
- All 12 requirements covered: WKFL-03, WKFL-04, WKFL-05, WKFL-06, TEST-01, TEST-02, TEST-03, TEST-04, TEST-05, UIAX-05, UIAX-06, CLI-04
</success_criteria>

<output>
After completion, create `.planning/phases/03-execution-testing/03-04-SUMMARY.md`
</output>
