---
phase: 06-interfaces-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/engine.ts
  - src/core/index.ts
  - src/cli/commander-cli.ts
  - src/cli/index.ts
  - src/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "User can run `npx afterburn <url>` and get a full scan"
    - "Terminal shows ora spinners for each pipeline stage during scan"
    - "On completion, terminal shows one-liner health score + issue count"
    - "Report file paths are printed after summary"
    - "All CLI flags work: --source, --email, --password, --output-dir, --flows, --max-pages"
    - "Reports are saved to ./afterburn-reports/{timestamp}/ by default"
  artifacts:
    - path: "src/core/engine.ts"
      provides: "Reusable runAfterburn() function that MCP and GitHub Action can also call"
      exports: ["runAfterburn", "AfterBurnOptions", "AfterBurnResult"]
    - path: "src/core/index.ts"
      provides: "Barrel export for core engine"
      exports: ["runAfterburn", "AfterBurnOptions", "AfterBurnResult"]
    - path: "src/cli/commander-cli.ts"
      provides: "Commander.js program with all flags and action handler"
      exports: ["program"]
    - path: "src/index.ts"
      provides: "CLI entry point with shebang that invokes Commander program"
  key_links:
    - from: "src/index.ts"
      to: "src/cli/commander-cli.ts"
      via: "imports and calls program.parse()"
      pattern: "program\\.parse"
    - from: "src/cli/commander-cli.ts"
      to: "src/core/engine.ts"
      via: "action handler calls runAfterburn()"
      pattern: "runAfterburn"
    - from: "src/core/engine.ts"
      to: "src/discovery/index.ts"
      via: "imports and calls runDiscovery()"
      pattern: "runDiscovery"
---

<objective>
Extract the core pipeline into a reusable engine function and build the Commander.js CLI wrapper.

Purpose: The current src/index.ts has the full pipeline hardcoded with manual argv parsing. We need to (1) extract the pipeline into a reusable `runAfterburn()` function that MCP and GitHub Action can also call, and (2) replace manual argv parsing with Commander.js for proper flag handling, help text, and npx compatibility.

Output: `src/core/engine.ts` with reusable pipeline, `src/cli/commander-cli.ts` with Commander.js wrapper, updated `src/index.ts` as thin CLI entry point.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-interfaces-integration/06-CONTEXT.md
@.planning/phases/06-interfaces-integration/06-RESEARCH.md

@src/index.ts
@src/cli/index.ts
@src/cli/progress.ts
@src/cli/first-run.ts
@src/reports/index.ts
@src/discovery/index.ts
@src/execution/index.ts
@src/analysis/index.ts
@package.json
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract core engine into reusable function</name>
  <files>src/core/engine.ts, src/core/index.ts</files>
  <action>
Create `src/core/engine.ts` that extracts the pipeline logic from the current `src/index.ts` into a reusable async function.

Define interfaces:

```typescript
export interface AfterBurnOptions {
  targetUrl: string;
  sessionId?: string;            // Auto-generate UUID if not provided
  sourcePath?: string;           // --source flag
  email?: string;                // --email flag
  password?: string;             // --password flag
  outputDir?: string;            // defaults to ./afterburn-reports/{timestamp}/
  flowHints?: string[];          // --flows flag parsed
  maxPages?: number;             // --max-pages flag, 0 = unlimited
  headless?: boolean;            // defaults true
  onProgress?: (stage: string, message: string) => void;  // Progress callback for all interfaces
}

export interface AfterBurnResult {
  healthScore: HealthScore;
  prioritizedIssues: PrioritizedIssue[];
  totalIssues: number;
  highPriorityCount: number;
  mediumPriorityCount: number;
  lowPriorityCount: number;
  workflowsPassed: number;
  workflowsTotal: number;
  htmlReportPath: string | null;
  markdownReportPath: string | null;
  exitCode: number;              // 0 = all pass, 1 = issues found
  sessionId: string;
}
```

Create `runAfterburn(options: AfterBurnOptions): Promise<AfterBurnResult>` that:
1. Generates sessionId if not provided (crypto.randomUUID())
2. Creates outputDir if it doesn't exist (use `./afterburn-reports/${Date.now()}/` as default)
3. Runs discovery pipeline (calls `runDiscovery()`)
4. Runs execution pipeline (calls `WorkflowExecutor.execute()`)
5. Runs analysis pipeline (calls `analyzeErrors()`, `mapErrorToSource()`, `auditUI()`)
6. Generates reports (calls `generateHtmlReport()`, `generateMarkdownReport()`)
7. Saves reports to outputDir (HTML and Markdown)
8. Calculates health score and prioritizes issues
9. Calls `onProgress` callback at each stage transition with stage name and message
10. Returns `AfterBurnResult` with all data needed by CLI/MCP/Action
11. Wraps report generation in try/catch for graceful degradation (matches existing behavior)
12. Does NOT call process.exit() — that's the caller's job

Stage names for onProgress: 'browser', 'discovery', 'execution', 'analysis', 'reporting', 'complete'

Port the exact pipeline logic from current `src/index.ts` — do NOT change behavior, just extract into reusable form. The key difference: reports save to `outputDir` instead of `.afterburn/reports/`.

Create `src/core/index.ts` barrel export:
```typescript
export { runAfterburn } from './engine.js';
export type { AfterBurnOptions, AfterBurnResult } from './engine.js';
```

IMPORTANT: Use .js extensions in all imports (ESM requirement).
  </action>
  <verify>Run `npx tsc --noEmit` to verify no type errors. Check that engine.ts imports from discovery, execution, analysis, and reports modules correctly.</verify>
  <done>src/core/engine.ts exports runAfterburn() that encapsulates full pipeline. src/core/index.ts barrel export exists. No type errors.</done>
</task>

<task type="auto">
  <name>Task 2: Build Commander.js CLI and rewire entry point</name>
  <files>src/cli/commander-cli.ts, src/cli/index.ts, src/index.ts, package.json</files>
  <action>
Create `src/cli/commander-cli.ts` with Commander.js program definition:

```typescript
import { Command } from 'commander';
import { runAfterburn } from '../core/index.js';
import { ensureBrowserInstalled, withSpinner } from './index.js';
import ora from 'ora';
```

Define the program:
- `.name('afterburn')`
- `.description('Automated testing for vibe-coded websites')`
- `.version('0.1.0')`
- `.argument('<url>', 'URL to test')`
- Required flags from CONTEXT.md decisions:
  - `--source <path>` — Source code directory for pinpointing bugs
  - `--email <email>` — Login email for authenticated testing
  - `--password <password>` — Login password
  - `--output-dir <path>` — Custom output directory (default: ./afterburn-reports/{timestamp})
  - `--flows <hints>` — Comma-separated workflow hints (e.g., "signup, checkout")
- Additional power-user flags (Claude's Discretion per CONTEXT.md):
  - `--max-pages <n>` — Max pages to crawl (default: 0 = unlimited)
  - `--no-headless` — Show browser window (useful for debugging)
  - `--verbose` — Show detailed progress output

The `.action()` handler should:
1. Call `ensureBrowserInstalled()` first
2. Print "Afterburn v0.1.0\n" banner
3. Create onProgress callback that maps stage names to ora spinners:
   - 'browser' -> "Checking browser..."
   - 'discovery' -> "Crawling site..."
   - 'execution' -> "Testing workflows..."
   - 'analysis' -> "Analyzing results..."
   - 'reporting' -> "Generating reports..."
   - 'complete' -> stop spinner
   Use a single spinner instance that updates text per stage transition. Start spinner on first progress call, succeed on 'complete'.
4. Call `runAfterburn()` with parsed options, passing `maxPages` as `parseInt(opts.maxPages)` (Commander passes string values for option args)
5. Print one-liner summary: `"\nHealth: {score}/100 — {n} issues found ({h} high, {m} medium, {l} low)"`
6. Print report paths if they exist:
   ```
   Reports saved:
     HTML:     {htmlPath}
     Markdown: {mdPath}
   ```
7. Call `process.exit(result.exitCode)`

Parse `--flows` by splitting on comma: `opts.flows?.split(',').map(s => s.trim()).filter(Boolean)`

Export the program for the entry point to call.

Update `src/cli/index.ts` barrel to add:
```typescript
export { program } from './commander-cli.js';
```

Rewrite `src/index.ts` to be a thin entry point:
```typescript
#!/usr/bin/env node
// Afterburn CLI entry point
import { program } from './cli/index.js';
program.parse();
```

This replaces all the manual argv parsing that was there before. The entry point is now ~3 lines.

Update `package.json`:
- Verify `"bin": { "afterburn": "dist/index.js" }` is correct (it is)
- Add `"files": ["dist"]` field so npx only downloads compiled output
- No other changes needed — commander and ora are already in dependencies

IMPORTANT: Do NOT use `console.log` for progress — use ora spinners as specified in CONTEXT.md. The summary line and report paths go to console.log after spinner completes.

Vibe coder tone: "Afterburn v0.1.0" not "Afterburn Automated Web Testing Platform v0.1.0". Keep it clean.
  </action>
  <verify>
1. Run `npx tsc --noEmit` to verify no type errors
2. Run `npm run build` to compile
3. Run `node dist/index.js --help` — verify Commander help text displays all flags including --max-pages
4. Run `node dist/index.js --help` and confirm --max-pages appears with description "Max pages to crawl"
5. Test --max-pages parsing: `node -e "const { program } = require('./dist/cli/commander-cli.js'); program.parse(['node', 'test', 'http://example.com', '--max-pages', '5'])"` — should not throw (verifies the flag is registered and parseable)
  </verify>
  <done>Commander.js CLI works with all flags including --max-pages. `--help` shows usage with --max-pages listed. src/index.ts is a 3-line entry point. package.json has "files" field. No type errors.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — no type errors
2. `npm run build` — compiles successfully
3. `node dist/index.js --help` — shows help with all flags (url, --source, --email, --password, --output-dir, --flows, --max-pages, --no-headless, --verbose)
4. `node dist/index.js --version` — shows "0.1.0"
5. `node dist/index.js` (no args) — shows error message with usage hint
6. Verify `dist/index.js` starts with `#!/usr/bin/env node` (shebang preserved)
7. Verify --max-pages flag is listed in help output and accepted without error
</verification>

<success_criteria>
- Core engine is extracted into reusable function that MCP and GitHub Action can import
- Commander.js CLI provides all required flags with proper help text
- --max-pages flag is registered, parseable, and passed to engine as maxPages option
- Entry point is thin (imports program, calls parse)
- onProgress callback enables ora spinners per stage
- Summary line shows health score + issue counts in vibe-coder-friendly format
- Reports default to ./afterburn-reports/{timestamp}/ directory
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-interfaces-integration/06-01-SUMMARY.md`
</output>
