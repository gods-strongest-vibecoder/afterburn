---
phase: 06-interfaces-integration
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/mcp/server.ts
  - src/mcp/tools.ts
  - src/mcp/index.ts
  - src/mcp/entry.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "MCP server starts via stdio transport and responds to tool discovery"
    - "AI coding assistant can invoke scan_website tool with a URL"
    - "MCP returns both structured JSON AND markdown summary in response"
    - "MCP sends progress notifications during long-running scans"
    - "MCP server handles errors gracefully without crashing"
  artifacts:
    - path: "src/mcp/server.ts"
      provides: "MCP server initialization and transport setup"
      exports: ["createServer", "startServer"]
    - path: "src/mcp/tools.ts"
      provides: "Tool definitions and handlers for scan_website"
      exports: ["registerTools"]
    - path: "src/mcp/index.ts"
      provides: "Barrel export for MCP module"
    - path: "src/mcp/entry.ts"
      provides: "MCP server entry point for bin field"
    - path: "package.json"
      provides: "afterburn-mcp bin entry and @modelcontextprotocol/sdk dependency"
      contains: "afterburn-mcp"
  key_links:
    - from: "src/mcp/tools.ts"
      to: "src/core/engine.ts"
      via: "imports and calls runAfterburn()"
      pattern: "runAfterburn"
    - from: "src/mcp/server.ts"
      to: "src/mcp/tools.ts"
      via: "registers tool handlers on server"
      pattern: "registerTools"
    - from: "src/mcp/entry.ts"
      to: "src/mcp/server.ts"
      via: "imports and calls startServer()"
      pattern: "startServer"
---

<objective>
Build the MCP server that exposes Afterburn as a tool for AI coding assistants.

Purpose: AI coding assistants (Claude, Cursor, Windsurf) can invoke Afterburn programmatically via MCP to scan a website, get structured results, and automatically fix issues. This is a key differentiator — Afterburn becomes part of the AI coding workflow, not a separate step.

Output: MCP server with scan_website tool, stdio transport, structured JSON + markdown responses, progress notifications.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-interfaces-integration/06-CONTEXT.md
@.planning/phases/06-interfaces-integration/06-RESEARCH.md

# Need engine from Plan 01
@src/core/engine.ts
@src/core/index.ts
@package.json
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install MCP SDK and create server with tool definitions</name>
  <files>src/mcp/server.ts, src/mcp/tools.ts, src/mcp/index.ts, src/mcp/entry.ts, package.json</files>
  <action>
**Step 1: Install dependency**
```bash
npm install @modelcontextprotocol/sdk
```

After install, inspect the package's TypeScript types to verify the exact API surface. The research flagged this as LOW confidence. Key things to verify:
- Import paths: `@modelcontextprotocol/sdk/server/index.js` and `@modelcontextprotocol/sdk/server/stdio.js`
- Server constructor signature
- How to register tool handlers (setRequestHandler vs method-based API)
- Progress notification method name and params shape

If the API differs from research examples, adapt to the actual types. The core concepts are stable: Server + StdioTransport + tool registration.

**Step 2: Create src/mcp/server.ts**

Server setup with stdio transport:
```typescript
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { registerTools } from './tools.js';

export function createServer(): Server {
  const server = new Server(
    { name: 'afterburn-mcp', version: '0.1.0' },
    { capabilities: { tools: {} } }
  );
  registerTools(server);
  return server;
}

export async function startServer(): Promise<void> {
  const server = createServer();
  const transport = new StdioServerTransport();
  await server.connect(transport);
}
```

Adapt constructor/method names based on actual SDK types found during install.

**Step 3: Create src/mcp/tools.ts**

Define and register the `scan_website` tool. Decision from CONTEXT.md: tools-only, return both JSON and markdown.

Tool: `scan_website`
- Inputs: `url` (required string), `source` (optional string path), `email` (optional), `password` (optional)
- Input schema: Use JSON Schema object directly (not zod — keep it simple, MCP SDK expects raw JSON Schema)
- Handler:
  1. Call `runAfterburn()` from core engine with options mapped from tool args
  2. Use `onProgress` callback to send MCP progress notifications if the SDK supports it. If progress notifications aren't straightforward, skip them (research flagged LOW confidence) — a working tool without streaming is better than a broken tool with streaming.
  3. Build response with two content blocks:
     - First: `type: 'text'` with JSON.stringify of structured result (healthScore, totalIssues, issues array with priority/summary/fix/location, workflowsPassed, workflowsTotal)
     - Second: `type: 'text'` with markdown summary (health score, issue count, top 5 issues with fixes)
  4. Return the response

The structured JSON should include enough data for an AI to act on:
```json
{
  "healthScore": 78,
  "healthLabel": "needs-work",
  "totalIssues": 5,
  "workflowsPassed": 3,
  "workflowsTotal": 4,
  "highPriorityIssues": 1,
  "mediumPriorityIssues": 2,
  "lowPriorityIssues": 2,
  "issues": [
    {
      "priority": "high",
      "category": "Workflow Error",
      "summary": "Login form submits but page shows error",
      "fix": "Check form action URL and server-side validation",
      "location": "https://example.com/login"
    }
  ],
  "reportPaths": {
    "html": "./afterburn-reports/1707400000/report.html",
    "markdown": "./afterburn-reports/1707400000/report.md"
  }
}
```

Error handling: Wrap runAfterburn call in try/catch. On error, return `isError: true` with error message as text content. Do NOT let the server crash.

**Step 4: Create src/mcp/index.ts** barrel export:
```typescript
export { createServer, startServer } from './server.js';
export { registerTools } from './tools.js';
```

**Step 5: Create src/mcp/entry.ts** — standalone entry point:
```typescript
#!/usr/bin/env node
// Afterburn MCP server entry point
import { startServer } from './server.js';
startServer().catch(console.error);
```

**Step 6: Update package.json**
Add second bin entry:
```json
"bin": {
  "afterburn": "dist/index.js",
  "afterburn-mcp": "dist/mcp/entry.js"
}
```

This allows `npx afterburn-mcp` to start the MCP server, and users configure it in their MCP client settings (claude_desktop_config.json, .cursor/mcp.json, etc).

IMPORTANT: The SDK import paths are the biggest risk. If `@modelcontextprotocol/sdk/server/index.js` doesn't resolve, try `@modelcontextprotocol/sdk/server` or check the package's exports map in node_modules. Adapt imports to match actual package structure.
  </action>
  <verify>
1. Run `npx tsc --noEmit` to verify no type errors
2. Run `npm run build` to compile
3. Verify `dist/mcp/entry.js` exists with shebang
4. Quick smoke test: `echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test","version":"0.1.0"}}}' | node dist/mcp/entry.js` — should see JSON-RPC response (may need to adapt protocol version)
  </verify>
  <done>MCP server compiles, starts via stdio, responds to initialization. scan_website tool is registered with correct input schema. Package.json has afterburn-mcp bin entry.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — no type errors
2. `npm run build` — compiles successfully
3. `dist/mcp/entry.js` exists and starts with shebang
4. MCP server starts without crashing when piped JSON-RPC initialize message
5. Tool list includes scan_website with url as required parameter
6. package.json bin field includes both afterburn and afterburn-mcp
</verification>

<success_criteria>
- MCP server starts via stdio and handles JSON-RPC messages
- scan_website tool accepts url (required), source, email, password inputs
- Tool handler calls runAfterburn() from core engine
- Response includes both structured JSON and markdown summary
- Errors are caught and returned as MCP error responses (server doesn't crash)
- Package can be started with `npx afterburn-mcp` or configured in MCP client settings
</success_criteria>

<output>
After completion, create `.planning/phases/06-interfaces-integration/06-02-SUMMARY.md`
</output>
