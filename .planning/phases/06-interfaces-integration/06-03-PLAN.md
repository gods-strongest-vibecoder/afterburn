---
phase: 06-interfaces-integration
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - action/action.yml
  - action/index.ts
  - action/tsconfig.json
  - package.json
autonomous: true

must_haves:
  truths:
    - "GitHub Action can be referenced in a workflow YAML and runs successfully"
    - "Action accepts url, source, email, password, github-token, and fail-on inputs"
    - "Action posts PR comment with health score, issue count, and top issues when in PR context"
    - "Action uploads HTML and Markdown reports as workflow artifacts"
    - "Action fails the workflow (exit 1) only when high-priority issues are found"
    - "Action outputs health-score and total-issues for downstream workflow steps"
  artifacts:
    - path: "action/action.yml"
      provides: "GitHub Action metadata with inputs, outputs, and runs config"
      contains: "runs:"
    - path: "action/index.ts"
      provides: "GitHub Action entry point that invokes core engine"
    - path: "action/tsconfig.json"
      provides: "TypeScript config for action/ directory compilation"
  key_links:
    - from: "action/index.ts"
      to: "src/core/engine.ts"
      via: "imports and calls runAfterburn()"
      pattern: "runAfterburn"
    - from: "action/index.ts"
      to: "@actions/core"
      via: "reads inputs, sets outputs, sets failed"
      pattern: "core\\.getInput|core\\.setOutput|core\\.setFailed"
    - from: "action/index.ts"
      to: "@actions/github"
      via: "posts PR comment via octokit"
      pattern: "createComment"
---

<objective>
Build the GitHub Action that runs Afterburn in CI/CD and posts results as PR comments.

Purpose: Developers add Afterburn to their GitHub workflow and get automatic scan results on every PR — health score in the PR comment, full reports as downloadable artifacts, and merge blocked only when high-priority issues exist. This makes Afterburn part of the deployment pipeline without any extra work.

Output: `action/action.yml` metadata, `action/index.ts` entry point, TypeScript config for separate compilation of action code.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-interfaces-integration/06-CONTEXT.md
@.planning/phases/06-interfaces-integration/06-RESEARCH.md

# Need engine from Plan 01
@src/core/engine.ts
@src/core/index.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Actions toolkit and create action.yml</name>
  <files>action/action.yml, package.json</files>
  <action>
**Step 1: Install GitHub Actions dependencies as devDependencies** (they're only used in CI, not by end users):
```bash
npm install --save-dev @actions/core @actions/github @actions/artifact
```

**Step 2: Create action/action.yml**

```yaml
name: 'Afterburn Web Testing'
description: 'Automated testing for vibe-coded websites — find bugs, get fixes'
author: 'Afterburn'

branding:
  icon: 'zap'
  color: 'orange'

inputs:
  url:
    description: 'URL to test'
    required: true
  source:
    description: 'Source code directory for pinpointing bugs to specific files'
    required: false
  email:
    description: 'Login email (store in GitHub Secrets)'
    required: false
  password:
    description: 'Login password (store in GitHub Secrets)'
    required: false
  github-token:
    description: 'GitHub token for posting PR comments'
    required: false
    default: '${{ github.token }}'
  fail-on:
    description: 'When to fail the workflow: "high" (default), "medium", "low", "never"'
    required: false
    default: 'high'

outputs:
  health-score:
    description: 'Overall health score (0-100)'
  total-issues:
    description: 'Total number of issues found'
  high-issues:
    description: 'Number of high-priority issues'

runs:
  using: 'node20'
  main: 'index.js'
```

Note: `runs.main` points to `index.js` (compiled JS in the action/ directory). The action uses node20 runtime.

The `fail-on` input implements the CONTEXT.md decision: "Fail the workflow (block merge) only when high-priority issues are found; medium/low issues warn but don't block." Default is 'high', but users can adjust.
  </action>
  <verify>Verify action/action.yml is valid YAML (no syntax errors). Check that all required inputs match CONTEXT.md decisions.</verify>
  <done>action/action.yml exists with correct inputs (url, source, email, password, github-token, fail-on), outputs (health-score, total-issues, high-issues), and runs.using node20.</done>
</task>

<task type="auto">
  <name>Task 2: Create Action entry point with PR comments and artifact upload</name>
  <files>action/index.ts, action/tsconfig.json</files>
  <action>
**Step 1: Create action/tsconfig.json** for separate compilation:
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "outDir": ".",
    "rootDir": ".",
    "strict": true,
    "esModuleInterop": true,
    "declaration": false,
    "sourceMap": false
  },
  "include": ["index.ts"],
  "exclude": ["node_modules"]
}
```

This compiles `action/index.ts` to `action/index.js` in the same directory (GitHub Actions expects the JS file at the path specified in action.yml).

**Step 2: Create action/index.ts**

```typescript
// GitHub Action entry point — runs Afterburn and posts results
import * as core from '@actions/core';
import * as github from '@actions/github';
import { DefaultArtifactClient } from '@actions/artifact';
import { runAfterburn } from '../src/core/index.js';
import type { AfterBurnResult } from '../src/core/index.js';
```

Main async function:
1. **Read inputs** via `core.getInput()`:
   - url (required)
   - source, email, password (optional)
   - github-token (for PR comments)
   - fail-on threshold ('high', 'medium', 'low', 'never')

2. **Run Afterburn** via `runAfterburn()`:
   - Map inputs to AfterBurnOptions
   - Set outputDir to a temp path or `./afterburn-reports/${Date.now()}/`
   - Use onProgress to log via `core.info()` for GitHub Actions log output

3. **Set outputs** via `core.setOutput()`:
   - 'health-score': result.healthScore.overall
   - 'total-issues': result.totalIssues
   - 'high-issues': result.highPriorityCount

4. **Upload artifacts** — Upload HTML and Markdown reports as workflow artifacts:
   ```typescript
   const artifactClient = new DefaultArtifactClient();
   const filesToUpload: string[] = [];
   if (result.htmlReportPath) filesToUpload.push(result.htmlReportPath);
   if (result.markdownReportPath) filesToUpload.push(result.markdownReportPath);
   if (filesToUpload.length > 0) {
     await artifactClient.uploadArtifact('afterburn-reports', filesToUpload, '.');
   }
   ```
   Note: Verify the uploadArtifact v4 API signature after install. Research flagged this as LOW confidence. The params may be (name, files, rootDir) or different. Check `@actions/artifact` TypeScript types.

5. **Post PR comment** if in PR context:
   ```typescript
   if (github.context.payload.pull_request) {
     const token = core.getInput('github-token');
     if (token) {
       const octokit = github.getOctokit(token);
       // Build comment body
       const comment = buildPRComment(result);
       await octokit.rest.issues.createComment({
         owner: github.context.repo.owner,
         repo: github.context.repo.repo,
         issue_number: github.context.payload.pull_request.number,
         body: comment,
       });
     }
   }
   ```

6. **Build PR comment** — Must be scannable in 5 seconds (CONTEXT.md decision):
   ```
   ## Afterburn Test Results

   **Health Score:** 78/100 (Needs Work)

   **Issues:** 5 found (1 high, 2 medium, 2 low)

   ### Top Issues

   | Priority | Issue | Fix |
   |----------|-------|-----|
   | HIGH | Login form submits but shows error | Check form action URL |
   | MEDIUM | Missing alt text on hero image | Add alt attribute |
   | MEDIUM | Console error on dashboard load | Fix undefined variable |

   ---
   *Full reports available as workflow artifacts*
   *Powered by [Afterburn](https://github.com/user/afterburn)*
   ```

   Show at most 5 top issues in the table (sorted by priority). Include the fix suggestion from PrioritizedIssue.

7. **Determine failure** based on fail-on threshold:
   ```typescript
   const failOn = core.getInput('fail-on') || 'high';
   let shouldFail = false;
   if (failOn === 'high' && result.highPriorityCount > 0) shouldFail = true;
   if (failOn === 'medium' && (result.highPriorityCount + result.mediumPriorityCount) > 0) shouldFail = true;
   if (failOn === 'low' && result.totalIssues > 0) shouldFail = true;
   // 'never' = never fail

   if (shouldFail) {
     core.setFailed(`Afterburn found ${result.highPriorityCount} high-priority issues`);
   }
   ```

8. **Error handling**: Wrap everything in try/catch, call `core.setFailed(error.message)` on any error.

**Step 3: Add build script for action**

Add to package.json scripts:
```json
"build:action": "tsc -p action/tsconfig.json"
```

IMPORTANT: The artifact upload API may differ from training data. After `npm install`, check `node_modules/@actions/artifact/lib/artifact.d.ts` or similar for the actual method signature. If `DefaultArtifactClient` doesn't exist, look for named exports like `create()` or `ArtifactClient`. Adapt code to match actual types.

IMPORTANT: The import path `'../src/core/index.js'` from action/index.ts depends on how the compiled output resolves. You may need to adjust based on tsconfig rootDir/outDir settings. An alternative is to import from the compiled dist: `'../dist/core/index.js'`. Test which works after compilation.
  </action>
  <verify>
1. Run `npx tsc -p action/tsconfig.json --noEmit` to verify no type errors
2. Verify action/action.yml is valid
3. Check that action/index.ts imports resolve correctly
  </verify>
  <done>action/index.ts compiles without errors. action.yml defines correct inputs/outputs/runs. PR comment builder creates scannable summary. Artifact upload code present. Failure threshold logic implements CONTEXT.md decision.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — main project has no type errors
2. `npx tsc -p action/tsconfig.json --noEmit` — action compiles without errors
3. action/action.yml has all required fields (name, inputs, outputs, runs)
4. action/index.ts correctly imports from core engine
5. PR comment template includes health score, issue count, top issues table
6. fail-on logic: 'high' only fails on high-priority, 'never' never fails
</verification>

<success_criteria>
- GitHub Action metadata (action.yml) defines all inputs and outputs
- Action entry point calls runAfterburn() and handles the result
- PR comment posted with health score + top 5 issues (scannable in 5 seconds)
- Reports uploaded as workflow artifacts
- Workflow fails only on high-priority issues by default (configurable via fail-on)
- Auth credentials read from inputs (which map to GitHub Secrets in user's workflow)
- Outputs set for downstream workflow steps
</success_criteria>

<output>
After completion, create `.planning/phases/06-interfaces-integration/06-03-SUMMARY.md`
</output>
