---
phase: 02-discovery-planning
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/ai/gemini-client.ts
  - src/ai/index.ts
  - src/planning/plan-schema.ts
  - src/planning/workflow-planner.ts
  - src/planning/index.ts
autonomous: true
user_setup:
  - service: gemini
    why: "AI workflow plan generation using Gemini 2.5 Flash"
    env_vars:
      - name: GEMINI_API_KEY
        source: "Google AI Studio (https://aistudio.google.com/apikey) -> Create API Key"

must_haves:
  truths:
    - "AI analyzes sitemap and generates workflow test plans with step-by-step actions"
    - "AI generates actionable test plans that Phase 3 can execute without manual editing"
    - "Workflows with steps below 0.7 confidence are flagged for review"
    - "User's --flows hints are incorporated as prioritized workflows"
  artifacts:
    - path: "src/ai/gemini-client.ts"
      provides: "Gemini 2.5 Flash API client with structured JSON output"
      exports: ["GeminiClient"]
      min_lines: 40
    - path: "src/planning/plan-schema.ts"
      provides: "Zod schemas for workflow plan structured output"
      exports: ["WorkflowPlanSchema", "WorkflowStepSchema"]
      min_lines: 30
    - path: "src/planning/workflow-planner.ts"
      provides: "AI workflow plan generator from sitemap"
      exports: ["WorkflowPlanner"]
      min_lines: 60
  key_links:
    - from: "src/planning/workflow-planner.ts"
      to: "src/ai/gemini-client.ts"
      via: "GeminiClient.generateStructured() for JSON output"
      pattern: "geminiClient|generateStructured"
    - from: "src/planning/workflow-planner.ts"
      to: "src/types/discovery.ts"
      via: "Consumes SitemapNode, produces WorkflowPlan[]"
      pattern: "SitemapNode|WorkflowPlan"
    - from: "src/planning/plan-schema.ts"
      to: "zod"
      via: "z.object() schema definitions"
      pattern: "z\\.object|z\\.enum|z\\.array"
---

<objective>
Build Gemini 2.5 Flash integration and AI-powered workflow plan generation from sitemap data.

Purpose: The workflow planner is the "brain" of Phase 2 — it takes the structured sitemap artifact and generates realistic step-by-step test plans that Phase 3 can execute mechanically. This is the core differentiator: zero-config workflow discovery powered by AI. The Gemini client is also reused in Phase 4 for error diagnosis.

Output: `src/ai/gemini-client.ts` for Gemini API wrapper, `src/planning/plan-schema.ts` for Zod schemas, `src/planning/workflow-planner.ts` for workflow generation logic.
</objective>

<execution_context>
@C:\Users\Shiv_\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Shiv_\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-discovery-planning/02-CONTEXT.md
@.planning/phases/02-discovery-planning/02-RESEARCH.md
@src/types/artifacts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build Gemini client and Zod workflow schemas</name>
  <files>src/ai/gemini-client.ts, src/ai/index.ts, src/planning/plan-schema.ts</files>
  <action>
**Install dependencies first:**
```bash
npm install @google/generative-ai zod zod-to-json-schema
```

**Create `src/ai/gemini-client.ts`:**

A reusable Gemini 2.5 Flash client that supports structured JSON output. This client will be reused in Phase 4 for error diagnosis and Phase 5 for report generation.

```typescript
class GeminiClient {
  private model: GenerativeModel;

  constructor(apiKey?: string)  // Falls back to process.env.GEMINI_API_KEY

  // Generate structured JSON output using a Zod schema
  async generateStructured<T>(prompt: string, schema: ZodType<T>): Promise<T>

  // Generate plain text response
  async generateText(prompt: string): Promise<string>
}
```

Implementation details:

1. Constructor: Create `GoogleGenerativeAI` instance with API key. If no key provided, read from `process.env.GEMINI_API_KEY`. Throw clear error if no key: "GEMINI_API_KEY not set. Get one at https://aistudio.google.com/apikey"
2. Model: Use `'gemini-2.5-flash'` model name.
3. `generateStructured()`:
   - Convert Zod schema to JSON Schema using `zodToJsonSchema()`
   - Set `generationConfig.responseMimeType` to `'application/json'`
   - Set `generationConfig.responseSchema` to the JSON schema
   - Call `model.generateContent()` with the prompt
   - Parse response text as JSON
   - Validate against Zod schema using `.parse()` — throw if validation fails
   - Return typed result
4. `generateText()`: Simple text generation, no schema constraints.
5. Add error handling: wrap API calls in try-catch, rethrow with context (e.g., "Gemini API error: {message}")

**Create `src/ai/index.ts`:** Barrel export for `GeminiClient`.

**Create `src/planning/plan-schema.ts`:**

Define Zod schemas that match the WorkflowPlan and WorkflowStep types from `src/types/discovery.ts`:

```typescript
import { z } from 'zod';

export const WorkflowStepSchema = z.object({
  action: z.enum(['navigate', 'click', 'fill', 'select', 'wait', 'expect']),
  selector: z.string().describe('Playwright selector for the target element (prefer role-based)'),
  value: z.string().optional().describe('Value to fill or select'),
  expectedResult: z.string().describe('What should happen after this step'),
  confidence: z.number().min(0).max(1).describe('How confident are you this step will work (0-1)'),
});

export const WorkflowPlanSchema = z.object({
  workflowName: z.string().describe('Human-readable name like "User Signup Flow"'),
  description: z.string().describe('What this workflow tests in plain English'),
  steps: z.array(WorkflowStepSchema).min(1).max(20),
  priority: z.enum(['critical', 'important', 'nice-to-have']),
  estimatedDuration: z.number().describe('Estimated seconds to execute'),
});

export const WorkflowPlansResponseSchema = z.object({
  workflows: z.array(WorkflowPlanSchema),
});
```

Export all schemas.

**Create `src/planning/index.ts`:** Barrel export for plan-schema and workflow-planner.

Add header comments to all files.
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors.

Verify Gemini client can be instantiated (doesn't need real API key for type checking):
```bash
npx tsc --noEmit
```
  </verify>
  <done>GeminiClient wraps Gemini 2.5 Flash with structured JSON output support. Zod schemas define the workflow plan format with validation. All types align with discovery.ts definitions.</done>
</task>

<task type="auto">
  <name>Task 2: Build AI workflow planner</name>
  <files>src/planning/workflow-planner.ts</files>
  <action>
Create `src/planning/workflow-planner.ts` with a `WorkflowPlanner` class.

**Import** `GeminiClient` from `../ai/index.js`, schemas from `./plan-schema.js`, types from `../types/discovery.js`.

```typescript
class WorkflowPlanner {
  private gemini: GeminiClient;

  constructor(geminiClient: GeminiClient)

  async generatePlans(sitemap: SitemapNode, userHints?: string[]): Promise<WorkflowPlan[]>
}
```

**generatePlans() implementation:**

1. **Prepare sitemap summary** for the LLM prompt. Don't send raw PageData (too verbose). Create a condensed summary:
   - For each page: URL, title, list of forms (with field names), list of buttons (text only), number of links
   - Tree structure showing navigation paths
   - Total page count

2. **Token limit handling for summarizeSitemap():**
   The summary MUST stay within ~10K tokens (~40K chars) to avoid exceeding Gemini's context window and to keep responses focused. Implement truncation:
   - Count characters as the summary is built
   - If total exceeds 40,000 characters, stop adding pages and append: `\n... and {N} more pages (truncated for brevity). Focus workflows on the pages shown above.`
   - Prioritize pages by importance: homepage first, then pages with forms, then pages with the most interactive elements, then remaining pages sorted by depth (shallow first)
   - This ensures the most workflow-relevant pages are always included even on large sites (50+ pages)

3. **Construct the prompt:**
```
You are analyzing a website to identify realistic user workflows that should be tested.

SITE STRUCTURE:
{condensed sitemap summary}

{if userHints:}
USER-SPECIFIED WORKFLOWS TO PRIORITIZE:
{userHints joined with newlines}
{endif}

Generate workflow test plans for this website. For each workflow:

1. Identify a realistic user journey (signup, login, checkout, search, contact form, navigation, etc.)
2. Create step-by-step plan using Playwright selectors
3. Prefer role-based selectors: getByRole('button', { name: 'Sign Up' }), getByLabel('Email')
4. Include expected result for each step (what the user should see after the action)
5. Assign confidence 0-1 for each step (1.0 = selector definitely exists, 0.5 = guessing)
6. Assign priority: critical (auth, core features), important (secondary features), nice-to-have (edge cases)

Focus on workflows that a real user would actually do. Skip admin/internal paths.
If user provided hints, those workflows are top priority.

Return JSON with a "workflows" array.
```

4. **Call Gemini** with structured output using WorkflowPlansResponseSchema.

5. **Post-process results:**
   - Filter out steps with confidence < 0.3 (likely hallucinated)
   - Flag workflows where any step has confidence < 0.7 (add note to description: "[Low confidence - verify selectors]")
   - Mark source: 'user-hint' for workflows matching user hints, 'auto-discovered' for others
   - Sort by priority: critical first, then important, then nice-to-have

6. **Handle errors gracefully:**
   - If Gemini API fails: return empty array with console.warn, don't crash
   - If JSON parsing fails: retry once with simpler prompt
   - If zero workflows generated: log warning

**Helper: summarizeSitemap(node: SitemapNode, options?: { maxChars?: number }): string**

Recursively walks the sitemap tree and produces a condensed text representation:
```
Page: Home (/)
  Forms: contact form (name, email, message)
  Buttons: "Get Started", "Learn More"
  Links: 12 internal, 3 external

  Page: Dashboard (/dashboard)
    Forms: search (query)
    Buttons: "New Project", "Settings"
    Links: 8 internal
    ...
```

Before recursing, sort children by importance: pages with forms first, then by number of interactive elements (descending). Track cumulative character count and stop adding pages once maxChars (default 40000) is reached.

Export WorkflowPlanner class. Add header comment.
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors.</verify>
  <done>WorkflowPlanner generates AI-powered workflow test plans from sitemap data. Plans include step-by-step actions with selectors, confidence scores, and priorities. User hints are prioritized. Low-confidence steps are flagged. Large sitemaps (50+ pages) are truncated to stay within token limits.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm install` succeeds with new dependencies (@google/generative-ai, zod, zod-to-json-schema)
- `src/ai/gemini-client.ts` exports GeminiClient
- `src/planning/plan-schema.ts` exports WorkflowPlanSchema and WorkflowStepSchema
- `src/planning/workflow-planner.ts` exports WorkflowPlanner
- GeminiClient throws clear error when API key is missing
- Zod schemas match the WorkflowPlan/WorkflowStep types in discovery.ts
- summarizeSitemap truncates output at ~40K chars for large sites
</verification>

<success_criteria>
- GeminiClient wraps Gemini 2.5 Flash with structured JSON output
- Zod schemas enforce workflow plan structure with validation
- WorkflowPlanner generates workflow plans from sitemap via AI
- User hints are incorporated as prioritized workflows
- Low-confidence steps (< 0.7) are flagged
- API errors don't crash the tool (graceful degradation)
- Large sites (50+ pages) don't exceed token limits in summarizeSitemap
</success_criteria>

<output>
After completion, create `.planning/phases/02-discovery-planning/02-04-SUMMARY.md`
</output>
