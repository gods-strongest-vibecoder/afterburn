---
phase: 02-discovery-planning
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/discovery/spa-detector.ts
  - src/discovery/element-mapper.ts
autonomous: true

must_haves:
  truths:
    - "Tool detects React, Vue, Angular, Next.js, Nuxt, and Svelte frameworks on any page"
    - "Tool discovers all visible buttons, links, forms, and menu items on a page"
    - "Tool triggers hidden elements (clicks buttons, hovers menus) to discover modals, dropdowns, and mobile nav"
    - "Form field inventory includes type, name, required/optional, placeholder, and label for each field"
  artifacts:
    - path: "src/discovery/spa-detector.ts"
      provides: "SPA framework detection and History API route interception"
      exports: ["detectSPAFramework", "interceptRouteChanges"]
      min_lines: 50
    - path: "src/discovery/element-mapper.ts"
      provides: "Interactive element discovery per page"
      exports: ["discoverElements", "discoverHiddenElements"]
      min_lines: 80
  key_links:
    - from: "src/discovery/spa-detector.ts"
      to: "playwright Page object"
      via: "page.evaluate() for framework detection"
      pattern: "page\\.evaluate"
    - from: "src/discovery/element-mapper.ts"
      to: "playwright Page object"
      via: "page.getByRole() and page.locator() for element discovery"
      pattern: "page\\.getByRole|page\\.locator"
    - from: "src/discovery/element-mapper.ts"
      to: "src/types/discovery.ts"
      via: "Returns PageData-compatible element arrays"
      pattern: "InteractiveElement|FormInfo|LinkInfo"
---

<objective>
Build SPA framework detection and interactive element discovery modules that extract complete UI surface from any page.

Purpose: These two modules are called per-page during crawling. The SPA detector identifies client-side routing frameworks and intercepts History API to discover routes invisible to traditional crawlers. The element mapper finds every interactive element (forms, buttons, links, menus, modals, dropdowns) including hidden ones that only appear after user interaction.

Output: `src/discovery/spa-detector.ts` for framework detection + route interception, `src/discovery/element-mapper.ts` for comprehensive element discovery.
</objective>

<execution_context>
@C:\Users\Shiv_\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Shiv_\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-discovery-planning/02-CONTEXT.md
@.planning/phases/02-discovery-planning/02-RESEARCH.md
@src/types/artifacts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build SPA framework detection and route interception</name>
  <files>src/discovery/spa-detector.ts</files>
  <action>
Create `src/discovery/spa-detector.ts` with two exported functions.

**Import** the `SPAFramework` type from `../types/discovery.js`.

**Function 1: detectSPAFramework(page: Page): Promise&lt;SPAFramework&gt;**

Uses `page.evaluate()` to detect framework from window properties and DOM attributes. Check in this ORDER (Next.js before React, Nuxt before Vue — meta-frameworks use the underlying framework internally):

1. **Next.js:** `document.querySelector('script#__NEXT_DATA__')` or `(window as any).__NEXT_DATA__`
2. **Nuxt:** `(window as any).__NUXT__` or `document.querySelector('[data-n-head]')`
3. **React:** `Object.keys(document.body).find(k => k.startsWith('__reactContainer'))` or `(window as any).__REACT_DEVTOOLS_GLOBAL_HOOK__`
4. **Vue:** `(window as any).__VUE__` or `(window as any).Vue` or `document.querySelector('[data-v-]')` (attribute starts with data-v-)
5. **Angular:** `(window as any).ng` or `document.querySelector('[ng-version]')` or `document.querySelector('app-root')`
6. **Svelte:** `document.querySelector('[data-svelte-h]')` or checking for `__svelte` on elements
7. **None:** No framework detected

Return `{ framework, version?, router? }`. For version, try to extract from __NEXT_DATA__ (Next.js), ng.version (Angular), etc. Don't fail if version unavailable — just omit.

**Function 2: interceptRouteChanges(page: Page): Promise&lt;string[]&gt;**

Intercepts History API to discover client-side routes:

1. Inject script via `page.addInitScript()` that wraps `history.pushState` and `history.replaceState` to record URL changes into `(window as any).__afterburn_routes = []`
2. Find all navigation-like elements: `page.getByRole('link').all()` + `page.locator('nav a, [role="navigation"] a').all()`
3. For each navigation element with an internal href (starts with `/` or same hostname):
   - Store current URL
   - Click with short timeout (2000ms) — catch and continue on failure
   - Wait for `page.waitForLoadState('domcontentloaded', { timeout: 3000 })` — catch timeout
   - Collect any new URLs from `__afterburn_routes` via `page.evaluate()`
   - Navigate back to original URL via `page.goBack()` (catch failures)
4. Also listen for `popstate` events during the process
5. Return array of unique discovered route URLs (resolved to absolute)

**Important safety considerations:**
- Wrap each click in try-catch — some elements may trigger downloads, alerts, or navigation away
- Set a hard timeout for the entire function (30 seconds) — if route discovery takes too long, return what we have
- Deduplicate discovered routes before returning
- Only click elements that look like navigation (skip buttons with text like "Delete", "Submit", "Cancel")
- Filter navigation-like text: look for links in `<nav>`, header, sidebar, or with href starting with `/`

Add 1-2 line header comment.
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors.</verify>
  <done>detectSPAFramework correctly identifies React/Vue/Angular/Next.js/Nuxt/Svelte from page evaluation. interceptRouteChanges discovers client-side routes by clicking navigation and intercepting History API.</done>
</task>

<task type="auto">
  <name>Task 2: Build interactive element mapper with hidden element discovery</name>
  <files>src/discovery/element-mapper.ts</files>
  <action>
Create `src/discovery/element-mapper.ts` with two exported functions.

**Import** types from `../types/discovery.js`: `InteractiveElement`, `FormInfo`, `FormField`, `LinkInfo`.

**Function 1: discoverElements(page: Page, pageUrl: string): Promise&lt;DiscoveredElements&gt;**

Where `DiscoveredElements` is:
```typescript
interface DiscoveredElements {
  forms: FormInfo[];
  buttons: InteractiveElement[];
  links: LinkInfo[];
  menus: InteractiveElement[];
  otherInteractive: InteractiveElement[];
}
```

Implementation:

**Forms:** Use `page.locator('form').all()` to find all forms. For each form:
- Extract `action` attribute (resolve relative to pageUrl), `method` attribute (default 'GET')
- Build a selector for the form (use nth-of-type if no id/name)
- Find all `input, textarea, select` within the form
- For each field: extract type, name, placeholder, aria-label, and required attribute
- Try to find associated `<label>` using `for` attribute matching or parent label element
- Create FormInfo with FormField array

**Buttons:** Use `page.getByRole('button').all()` to find all buttons. For each:
- Get textContent, aria-label, type attribute, disabled state
- Build selector: prefer `button:has-text("exact text")` when text is unique; fall back to nth index
- Record visibility with `button.isVisible()`
- Create InteractiveElement with type='button'

**Links:** Use `page.locator('a[href]').all()` to find all links with href. For each:
- Get href attribute, resolve to absolute URL using `new URL(href, pageUrl).href`
- Get text content (trim whitespace)
- Determine isInternal: compare hostname of resolved URL with hostname of pageUrl
- Create LinkInfo object
- Deduplicate by href (same URL linked multiple times = one entry)

**Menus:** Use `page.locator('nav, [role="navigation"], [role="menubar"]').all()` to find navigation containers. For each:
- Get all child links and buttons
- Create InteractiveElement with type='menu'
- Record the menu's visible text/aria-label

**Other interactive:** Find elements with these roles: `tab`, `tabpanel`, `dialog`, `combobox`, `listbox`. For each, create InteractiveElement with appropriate type.

**Function 2: discoverHiddenElements(page: Page, pageUrl: string): Promise&lt;DiscoveredElements&gt;**

Discovers elements that are hidden until user interaction (modals, dropdowns, mobile nav).

Implementation:

1. Take a "before" snapshot of visible element count
2. Find all buttons that might trigger hidden content:
   - Buttons with aria-expanded, aria-haspopup, data-toggle, data-bs-toggle attributes
   - Buttons with text matching: "menu", "nav", "more", "show", "open", "expand"
   - Hamburger menu buttons (common classes: hamburger, menu-toggle, navbar-toggler)
3. For each trigger button:
   - Click it (with 2000ms timeout, catch failures)
   - Wait 500ms for animations
   - Check for newly visible elements: `[role="dialog"]`, `[role="menu"]`, `.modal`, `.dropdown-menu`, `.nav-menu`
   - Run discoverElements() on newly visible content
   - Try to close/reset: click button again, press Escape, or click backdrop
4. Also try hover on nav items: `page.locator('nav li, [role="menubar"] > *').all()` — hover each, check for dropdown menus
5. Merge and deduplicate results with the visible elements
6. Return only the NEWLY discovered elements (subtract "before" snapshot)

**Safety:** Wrap each interaction in try-catch. Set per-interaction timeout of 3 seconds. If a modal can't be closed, reload the page and continue.

**Export** both functions and the DiscoveredElements interface.

Add 1-2 line header comment.
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors.</verify>
  <done>discoverElements finds all forms (with field inventory), buttons, links, menus, and other interactive elements on a page. discoverHiddenElements triggers hidden UI (modals, dropdowns, hamburger menus) and discovers additional elements.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `src/discovery/spa-detector.ts` exports detectSPAFramework and interceptRouteChanges
- `src/discovery/element-mapper.ts` exports discoverElements and discoverHiddenElements
- SPA detector checks for Next.js before React (meta-framework priority)
- Element mapper extracts form fields with type, name, required, placeholder, label
- Hidden element discovery clicks triggers and captures newly visible content
</verification>

<success_criteria>
- SPA framework detection identifies 6 frameworks + "none"
- Route interception discovers client-side routes via History API wrapping
- Element discovery finds forms, buttons, links, menus on any page
- Hidden element discovery triggers modals, dropdowns, mobile nav
- Form field inventory is complete (type, name, required, placeholder, label)
- All interactions are safely wrapped with timeouts and error handling
</success_criteria>

<output>
After completion, create `.planning/phases/02-discovery-planning/02-02-SUMMARY.md`
</output>
